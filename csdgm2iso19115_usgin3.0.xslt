<?xml version="1.0" encoding="UTF-8"?>
<!--
======================================================================
	 FGDC CSDGM to ISO 19115 Transform version 3.0 using XSLT v1.0

	 This is the XML Style sheet that transforms metadata conforming to the Content Standards for Digital Geospatial Metadata of 
	 the Federal Geographic Data Committee 	 June 1998 FGDC-STD-001-1998 version to the ISO 19115:2007.  
	 This stylesheet can be applied to FGDC CSDGM XML to generate ISO 19115 XML.

	 Authors:
	     Original XSLT is the product of a collaboration of the Metadata Transform Working Group. For further information, 
	     please contact NOAA's National Coastal Data 
	     Development Center (NCDDC).
			Toll Free: 866.732.2382
			E-mail: ncddcmetadata@noaa.gov

	 Distribution liability on original XSLT:
		 NOAA makes no warranty regarding these data, expressed or implied, nor does the fact of distribution constitute such 
		 a warranty. NOAA, NESDIS,NODC and NCDDC cannot assume liability for any damages caused by any errors or 
		 omissions in these data, nor as a result of the failure of these data to function on a particular system. These 
		 files were developed for opensource uses.

	Original auto-generated XSLT extensively modified by Stephen Richard and Leahanna Musil, USGIN to make the operation 
	more intelligible and maintainable, adopt for USGIN ISO metadata conventions. 
	Spatial reference and entity-attribute information is put into the abstract as free text.
	

 Revisions:
	     20091028 (JLM) Namespaces were corrected to avoid duplicates.
							 xmlns:n="http://www.isotc211.org/2005/gfc" was changed
							 to xmlns:gfc="http://www.isotc211.org/2005/gfc" and
							 xmlns:n="http://www.opengis.net/gml/3.2" was changed to
							 xmlns:gml="http://www.opengis.net/gml/3.2". All used "n:" 
							 namespaces were changed to "gml:". 
		 20091120 (JLM) CodeLists were edited to remove extra quotes and other.
							 undesired characters. CodeLists were checked to ensure 
							 inclusion of domian codes. Edits were also made to remove 
							 un-used elements. FGDC CSDGM elements horizpa/horizpar and 
							 vertacc/vertaccr were changed from being mapped to gml:id to 
							 gml:CoventionalUnit. Single Date Time Period of contect was
							 added to mapping. Multiple Dates will replace if single date 
							 is empty. Duplicates of axisDimensionsProperties is not
							 allowed to repeat. To solve this, MD_GridSpatialRepresentation
							 was repeated. Cell Geometry Code information was also added.
SMR 2012-01-27 comment out gmd:extendedElementInformation
SMR 2012-01-28 edit xslt to make it more intelligible and maintainable. Give variables more 
							reasonable names, remove spurious type casting, add comments
Copied from https://github.com/usgin/usgin-geoportal/blob/d23f0a8fa96c855f01c8b30be80fb8031d122188/WEB-INF/classes/gpt/metadata/fgdc/csdgm2iso19115_usgin.xslt
2018-05-25, 
SMR 2018-05-30 massive revision to adapt for use with xslt 1.0 so php and python xslt libraries can use to automate transformation.
               Lots more autogenerated code that makes code hard to understand was removed. Distribution, Spatial representaiton and Lineage sections 
               completely rewritten. Add templates for citation and contact information.
-->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gfc="http://www.isotc211.org/2005/gfc"
	xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:gmx="http://www.isotc211.org/2005/gmx"
	xmlns:gsr="http://www.isotc211.org/2005/gsr" xmlns:gss="http://www.isotc211.org/2005/gss"
	xmlns:gts="http://www.isotc211.org/2005/gts" xmlns:gml="http://www.opengis.net/gml"
	xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:vmf="http://www.altova.com/MapForce/UDF/vmf"
	xmlns:grp="http://www.altova.com/Mapforce/grouping"
	xmlns:usgin="http://resources.usgin.org/xslt/FGDC2ISO"
	xmlns:datetime="http://exslt.org/dates-and-times"
	exclude-result-prefixes="grp vmf xs xsi xsl usgin" xmlns="http://www.opengis.net/gml">
	<!-- ********************** templates by SMR   **************************** -->

	<xsl:variable name="currentDateTime">
		<xsl:value-of select="datetime:date-time()"/>
	</xsl:variable>

<!-- use these to implement uppercase and lower case string functions -->
	<xsl:variable name="smallcase" select="'abcdefghijklmnopqrstuvwxyz'"/>
	<xsl:variable name="uppercase" select="'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"/>
	
	<xsl:template name="usgin:dateFormat">
		<xsl:param name="inputDate"/>
		<xsl:param name="inputTime"/>
		<!-- var_DateString will contain either 'nilAAAAA' where AAAA is a nilReason, a valid xs:dateTime, or it will contain a valid Date in format YYYY-MM-DD -->
		<xsl:variable name="var_DateString">
			<xsl:choose>
				<xsl:when
					test="(contains(string($inputDate), 'unknown') or contains(string($inputDate), 'unpublished'))">
					<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="string(normalize-space(string(.)))"/></xsl:attribute -->
					<xsl:value-of select="concat('nil', string($inputDate))"/>
				</xsl:when>
				<xsl:when
					test="contains(string($inputDate), 'present')">
					<!--gco:DateTime -->
					<xsl:value-of select="string($currentDateTime)"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<!--			<xsl:when test="(normalize-space(string($inputDate)) castable as xs:dateTime)"> -->
				<xsl:when
					test="(substring($inputDate, 5, 1) = '-') and (substring($inputDate, 8, 1) = '-')">
					<!-- gco:DateTime -->
					<xsl:value-of select="string($inputDate)"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<!-- convert YYYYMMDD format to YYYY-MM-DD format -->
				<xsl:otherwise>
					<xsl:variable name="var_dateString_result">
						<xsl:choose>
							<xsl:when
								test="string-length(normalize-space(string($inputDate))) = 8">
								<xsl:value-of
									select="concat(substring(normalize-space(string($inputDate)), 0, 5), '-', substring(normalize-space(string($inputDate)), 5, 2), '-', substring(normalize-space(string($inputDate)), 7, 2))"
								/>
							</xsl:when>
							<xsl:when
								test="string-length(normalize-space(string($inputDate))) = 6">
								<xsl:value-of
									select="concat(substring(normalize-space(string($inputDate)), 0, 5), '-', substring(normalize-space(string($inputDate)), 5, 2), '-01')"
								/>
							</xsl:when>
							<xsl:when
								test="string-length(normalize-space(string($inputDate))) = 4">
								<xsl:value-of
									select="concat(substring(normalize-space(string($inputDate)), 0, 5), '-01-01')"
								/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="string('nilmissing')"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:choose>
						<xsl:when
							test="(substring($var_dateString_result, 5, 1) = '-') and (substring($var_dateString_result, 8, 1) = '-')">
							<!-- gco:DateTime -->
							<xsl:value-of select="$var_dateString_result"/>
							<!-- /gco:DateTime -->
						</xsl:when>
						<xsl:otherwise>
							<!-- date format is screwy, put in default value -->
							<xsl:value-of select="string('nilmissing')"/>
							<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="string('InvalidValue')"/></xsl:attribute>
							<gco:DateTime>1900-01-01T12:00:00Z</gco:DateTime -->
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<!-- done with date, either is nilAAAAA, 0000, a valid xs:dateTime, or a valid xs:date -->
		<!-- now need to process input time  -->
		<xsl:variable name="var_timeString">
			<!-- xsl:if test="exists($inputTime)" -->
			<xsl:choose>
				<xsl:when test="(translate(string(.), $smallcase, $uppercase) = 'UNKNOWN')">
					<xsl:value-of select="string('12:00:00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime) = 6">
					<xsl:value-of
						select="concat(substring(string($inputTime), 0, 3), ':', substring(string($inputTime), 3, 2), ':', substring(string($inputTime), 5, 2))"
					/>
				</xsl:when>
				<xsl:when test="string-length($inputTime) = 4">
					<xsl:value-of
						select="concat(substring(string($inputTime), 0, 3), ':', substring(string($inputTime), 3, 2), ':00')"
					/>
				</xsl:when>
				<xsl:when test="string-length($inputTime) = 2">
					<xsl:value-of
						select="concat(substring(string($inputTime), 0, 3), ':00:00')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="string('12:00:00')"/>
				</xsl:otherwise>
			</xsl:choose>
			<!-- /xsl:for-each-->
		</xsl:variable>
		<!-- now merge date string with time string (if it exists) -->
		<xsl:choose>
			<xsl:when test="starts-with(string($var_DateString), 'nil')">
				<xsl:value-of select="$var_DateString"/>
			</xsl:when>
			<!-- 1999-02-02T12:00:00 -->
<!--			<xsl:when
				test="(substring($var_DateString, 5, 1) = '-') and (substring($var_DateString, 8, 1) = '-')">
					<xsl:value-of select="string($var_DateString)"/>
			</xsl:when>-->
			<xsl:when
				test="$var_DateString and (string-length($var_DateString) = 10) and (string-length($var_timeString) = 8)">
					<xsl:value-of select="concat(string($var_DateString), 'T', string($var_timeString))" />
			</xsl:when>
			<xsl:when
				test="$var_DateString and (string-length($var_DateString) = 10) and not(string-length($var_timeString) = 8)">
					<xsl:value-of select="concat(string($var_DateString), 'T12:00:00')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="string('nilmissing')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="usgin:TimePositionFormat">
		<xsl:param name="inputDate"/>
		<xsl:param name="inputTime"/>
		<!-- var_DateString will contain either 'nilAAAAA' where AAAA is a nilReason, a valid xs:dateTime, or it will contain a valid Date in format YYYY-MM-DD -->
		<xsl:variable name="var_DateString">
			<xsl:choose>
				<xsl:when
					test="(contains(string($inputDate), 'unknown') or contains(string($inputDate), 'unpublished'))">
					<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="string(normalize-space(string(.)))"/></xsl:attribute -->
					<xsl:value-of select="concat('nil', string($inputDate))"/>
				</xsl:when>
				<xsl:when
					test="contains(string($inputDate), 'present')">
					<!--gco:DateTime -->
					<xsl:value-of select="$currentDateTime"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<xsl:when
					test="(substring($inputDate, 5, 1) = '-') and (substring($inputDate, 8, 1) = '-')">
					<!-- gco:DateTime -->
					<xsl:value-of select="string($inputDate)"/>
					<!-- /gco:DateTime -->
				</xsl:when>
				<!-- convert YYYYMMDD format to YYYY-MM-DD format -->
				<xsl:otherwise>
					<xsl:variable name="var_dateString_result">
						<xsl:choose>
							<xsl:when
								test="string-length(normalize-space(string($inputDate))) = 8">
								<xsl:value-of
									select="concat(substring(normalize-space(string($inputDate)), 0, 5), '-', substring(normalize-space(string($inputDate)), 5, 2), '-', substring(normalize-space(string($inputDate)), 7, 2))"
								/>
							</xsl:when>
							<xsl:when
								test="string-length(normalize-space(string($inputDate))) = 6">
								<xsl:value-of
									select="concat(substring(normalize-space(string($inputDate)), 0, 5), '-', substring(normalize-space(string($inputDate)), 5, 2), '-01')"
								/>
							</xsl:when>
							<xsl:when
								test="string-length(normalize-space(string($inputDate))) = 4">
								<xsl:value-of
									select="concat(substring(normalize-space(string($inputDate)), 0, 5), '-01-01')"
								/>
							</xsl:when>
							<xsl:otherwise>
								<xsl:value-of select="string('nilmissing')"/>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:variable>
					<xsl:choose>
						<xsl:when
							test="(substring($var_dateString_result, 5, 1) = '-') and (substring($var_dateString_result, 8, 1) = '-')">
							<xsl:value-of select="$var_dateString_result"/>
							<!-- /gco:DateTime -->
						</xsl:when>
						<xsl:otherwise>
							<!-- date format is screwy, put in default value -->
							<xsl:value-of select="string('nilmissing')"/>
							<!-- xsl:attribute name="gco:nilReason"><xsl:value-of select="string('InvalidValue')"/></xsl:attribute>
							<gco:DateTime>1900-01-01T12:00:00Z</gco:DateTime -->
						</xsl:otherwise>
					</xsl:choose>
				</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>
		<!-- done with date, either is nilAAAAA, 0000, a valid xs:dateTime, or a valid xs:date -->
		<!-- now need to process input time  -->
		<xsl:variable name="var_timeString">
			<!-- xsl:if test="exists($inputTime)" -->
			<xsl:choose>
				<xsl:when test="(translate(string(.), $smallcase, $uppercase) = 'UNKNOWN')">
					<xsl:value-of select="string('12:00:00')"/>
				</xsl:when>
				<xsl:when test="string-length($inputTime) = 6">
					<xsl:value-of
						select="concat(substring(string($inputTime), 0, 3), ':', substring(string($inputTime), 3, 2), ':', substring(string($inputTime), 5, 2))"
					/>
				</xsl:when>
				<xsl:when test="string-length($inputTime) = 4">
					<xsl:value-of
						select="concat(substring(string($inputTime), 0, 3), ':', substring(string($inputTime), 3, 2), ':00')"
					/>
				</xsl:when>
				<xsl:when test="string-length($inputTime) = 2">
					<xsl:value-of
						select="concat(substring(string($inputTime), 0, 3), ':00:00')"/>
				</xsl:when>
				<xsl:otherwise>
					<xsl:value-of select="string('12:00:00')"/>
				</xsl:otherwise>
			</xsl:choose>
			<!-- /xsl:for-each-->
		</xsl:variable>
		<!-- now merge date string with time string (if it exists) -->
		<xsl:choose>
			<xsl:when test="starts-with(string($var_DateString), 'nil')">
				<xsl:value-of select="string('indeterminate')"/>
			</xsl:when>
			<xsl:when
				test="(substring($var_DateString, 5, 1) = '-') and (substring($var_DateString, 8, 1) = '-')">
				<xsl:value-of select="string($var_DateString)"/>
			</xsl:when>
			<xsl:when
				test="$var_DateString and (string-length($var_DateString) = 10) and (string-length($var_timeString) = 8)">
				<xsl:value-of
					select="concat(string($var_DateString), 'T', string($var_timeString))"
				/>
			</xsl:when>
			<xsl:when
				test="$var_DateString and (string-length($var_DateString) = 10) and not(string-length($var_timeString) = 8)">
				<xsl:value-of select="concat(string($var_DateString), 'T12:00:00')"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="string('indeterminate')"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="usgin:contactName">
		<xsl:param name="inputPersonNode"/>
		<xsl:param name="inputOrganizationNode"/>
		<xsl:param name="inputPositionNode"/>
		<!-- handler for individual, organization, position name -->
		<!-- done scraping content for contact name -->
		<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
		<!-- check that at least one got populated -->
		<xsl:choose>
			<xsl:when
				test="$inputPersonNode or $inputOrganizationNode or $inputPositionNode">
				<xsl:if test="$inputPersonNode">
					<gmd:individualName>
						<gco:CharacterString>
							<xsl:value-of select="normalize-space(string($inputPersonNode))"/>
						</gco:CharacterString>
					</gmd:individualName>
				</xsl:if>
				<xsl:if test="$inputOrganizationNode">
					<gmd:organisationName>
						<gco:CharacterString>
								<xsl:value-of select="normalize-space(string($inputOrganizationNode))"/>
						</gco:CharacterString>
					</gmd:organisationName>
				</xsl:if>
				<xsl:if test="$inputPositionNode">
						<gmd:positionName>
							<gco:CharacterString>
								<xsl:value-of select="normalize-space(string($inputPositionNode))"/>
							</gco:CharacterString>
						</gmd:positionName>
				</xsl:if>
			</xsl:when>
			<!-- if at least one is present check -->
			<!-- no contact name -->
			<xsl:otherwise>
				<gmd:organisationName>
					<gco:CharacterString>Contact name, organisation and position are missing</gco:CharacterString>
				</gmd:organisationName>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<!-- *************************************************** -->
	<xsl:template name="usgin:addressFormat">
		<xsl:param name="inputAddr"/>
		<!-- don't put in postal address elements unless at least one has a value -->
		<xsl:if
			test="$inputAddr/address or $inputAddr/city or $inputAddr/state or $inputAddr/postal or $inputAddr/country">
			<xsl:for-each select="$inputAddr/address">
				<gmd:deliveryPoint>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:deliveryPoint>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/city">
				<gmd:city>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:city>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/state">
				<gmd:administrativeArea>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:administrativeArea>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/postal">
				<gmd:postalCode>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:postalCode>
			</xsl:for-each>
			<xsl:for-each select="$inputAddr/country">
				<gmd:country>
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</gmd:country>
			</xsl:for-each>
		</xsl:if>
	</xsl:template>
	<!-- ********************************************************** -->
	<xsl:template name="usgin:telephoneFormat">
		<xsl:param name="telNode"/>
		<xsl:variable name="var_voicePhone_exists">
			<xsl:if test="$telNode/cntvoice">
				<xsl:for-each select="$telNode/cntvoice">
					<xsl:value-of select="string(.)"/>
					<xsl:if test="position() != last()">
						<xsl:text>; </xsl:text>
					</xsl:if>
				</xsl:for-each>
			</xsl:if>
		</xsl:variable>
		<xsl:variable name="var_faxPhone_exists">
			<xsl:if test="$telNode/cntfax">
				<xsl:for-each select="$telNode/cntfax">
					<xsl:value-of select="string(.)"/>
					<xsl:if test="position() != last()">
						<xsl:text>; </xsl:text>
					</xsl:if>
				</xsl:for-each>
			</xsl:if>
		</xsl:variable>
		<!-- done checking  for phone number existance in the source record -->
		<!-- do the phone number(s) -->
		<xsl:if test="$var_voicePhone_exists or $var_faxPhone_exists">
			<gmd:phone>
				<gmd:CI_Telephone>
					<xsl:if test="$var_voicePhone_exists">
						<gmd:voice>
							<gco:CharacterString>
									<xsl:value-of select="normalize-space(string($var_voicePhone_exists))"/>
							</gco:CharacterString>
						</gmd:voice>
					</xsl:if>
					<xsl:if test="$var_faxPhone_exists">
						<gmd:facsimile>
							<gco:CharacterString>
									<xsl:value-of select="normalize-space(string($var_faxPhone_exists))"/>
							</gco:CharacterString>
						</gmd:facsimile>
					</xsl:if>
				</gmd:CI_Telephone>
			</gmd:phone>
		</xsl:if>
	</xsl:template>
	<!-- ********************************************************** -->
	<xsl:template name="usgin:emailFormat">
		<xsl:param name="emailNode"/>
		<!-- Set this up so that some value gets inserted -->
<!-- parameter is a cntinfo node; this is context -->
			<xsl:choose>
				<xsl:when test="cntemail">
					<xsl:for-each select="cntemail">
						<gmd:electronicMailAddress>
							<gco:CharacterString>
								<xsl:value-of select="normalize-space(string(.))"/>
							</gco:CharacterString>
						</gmd:electronicMailAddress>
					</xsl:for-each>
				</xsl:when>
				<xsl:otherwise>
					<gmd:electronicMailAddress>
						<gco:CharacterString>eMail@missing.org</gco:CharacterString>
					</gmd:electronicMailAddress>
				</xsl:otherwise>
			</xsl:choose>
	</xsl:template>
	<!-- ********************************************************** -->
	<!-- contact to responsibleParty template -->
	<xsl:template match="cntinfo">
<!-- this template generates content for a CI_ResponsiblePart from CSDGM cntinfo element, but 
			does not generate the gmd:CI_RoleCode element -->
		<!-- scrape input cntinfo for person and org names that might be in one of 2 places -->
		<xsl:variable name="var_IndividualName">
			<xsl:value-of select=".//cntper"/>
			<!-- could be cntperp/cntper or cntorgp/cntper -->
<!--			<xsl:for-each select=".//cntper">
				<xsl:value-of select="string(.)"/>
			</xsl:for-each>-->
		</xsl:variable>
		<xsl:variable name="var_OrganisationName">
			<xsl:value-of select=".//cntorg"/>
<!--			<xsl:for-each select=".//cntorg">
				<xsl:value-of select="string(.)"/>
			</xsl:for-each>-->
		</xsl:variable>
		<!-- done scraping content for contact name -->
		<!-- now populate the elements count(individualName + OrganisationName + positionName) must be >0 -->
		<xsl:call-template name="usgin:contactName">
			<xsl:with-param name="inputPersonNode" select="$var_IndividualName"/>
			<xsl:with-param name="inputOrganizationNode" select="$var_OrganisationName"/>
			<xsl:with-param name="inputPositionNode" select="cntpos"/>
		</xsl:call-template>
		<gmd:contactInfo>
			<gmd:CI_Contact>
				<!-- do the phone number(s) -->
				<xsl:call-template name="usgin:telephoneFormat">
					<xsl:with-param name="telNode" select="."/>
				</xsl:call-template>
				<gmd:address>
					<gmd:CI_Address>
						<!-- ISO only allows one address, so use the first if there are multiple -->
						<xsl:call-template name="usgin:addressFormat">
							<xsl:with-param name="inputAddr" select="cntaddr[1]"/>
						</xsl:call-template>
						<!-- done with postal address elements, now the e-mail. Set this up so that some value gets inserted -->
						<xsl:call-template name="usgin:emailFormat">
							<xsl:with-param name="emailNode" select="."/>
						</xsl:call-template>
					</gmd:CI_Address>
				</gmd:address>
				<xsl:if test="hours">
					<gmd:hoursOfService>
						<gco:CharacterString>
							<xsl:value-of select="normalize-space(string(hours))"/>
						</gco:CharacterString>
					</gmd:hoursOfService>
				</xsl:if>
				<xsl:if test="cntinst">
					<gmd:contactInstructions>
						<gco:CharacterString>
							<xsl:value-of select="normalize-space(string(cntinst))"/>
						</gco:CharacterString>
					</gmd:contactInstructions>
				</xsl:if>
			</gmd:CI_Contact>
		</gmd:contactInfo>
</xsl:template>
	<!-- *********************************************************** -->
	<!-- citation template -->
	<xsl:template match="citeinfo">
			<gmd:title>
				<xsl:for-each select="title">
					<gco:CharacterString>
						<xsl:value-of select="normalize-space(string(.))"/>
					</gco:CharacterString>
				</xsl:for-each>
			</gmd:title>
			<gmd:date>
				<gmd:CI_Date>
					<gmd:date>
						<xsl:choose>
							<xsl:when test="pubdate">
								<xsl:variable name="dateFormat">
									<xsl:call-template name="usgin:dateFormat">
										<xsl:with-param name="inputDate" select="normalize-space(string(pubdate))"/>
										<xsl:with-param name="inputTime" select="normalize-space(string(pubtime))"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:choose>
									<xsl:when test="starts-with(string($dateFormat), 'nil')">
										<xsl:attribute name="gco:nilReason">
											<xsl:value-of select="substring-after($dateFormat, 'nil')"/>
										</xsl:attribute>
										<xsl:attribute name="xlink:title">
											<xsl:value-of select="concat(string('Cannot interpret datestring: '), pubdate, 'T: ', pubtime)"/>
										</xsl:attribute>
										<gco:DateTime>1900-01-01T12:00:00</gco:DateTime>
									</xsl:when>
									<xsl:otherwise>
										<gco:DateTime>
										<xsl:value-of select="$dateFormat"/>
										</gco:DateTime>
									</xsl:otherwise>
								</xsl:choose>
							</xsl:when>
							<xsl:otherwise>
								<xsl:attribute name="gco:nilReason">missing</xsl:attribute>
							</xsl:otherwise>
						</xsl:choose>
					</gmd:date>
					<gmd:dateType>
						<gmd:CI_DateTypeCode
							codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_DateTypeCode"
							codeListValue="publication" codeSpace="002">publication</gmd:CI_DateTypeCode>
					</gmd:dateType>
				</gmd:CI_Date>
			</gmd:date>
			<xsl:for-each select="edition">
				<gmd:edition>
					<gco:CharacterString>
						<xsl:value-of select="string(.)"/>
					</gco:CharacterString>
				</gmd:edition>
			</xsl:for-each>
			<xsl:for-each select="onlink">
			<gmd:identifier>
				<gmd:MD_Identifier>
					<gmd:authority gco:nilReason="missing"/>
					<gmd:code>
						<gco:CharacterString>
							<xsl:value-of select="normalize-space(string(.))"/>
						</gco:CharacterString>
					</gmd:code>
				</gmd:MD_Identifier>
			</gmd:identifier>
			</xsl:for-each>
			<gmd:citedResponsibleParty>
				<gmd:CI_ResponsibleParty>
					<gmd:organisationName>
						<!--	concatenate all originator values for citation -->
						<gco:CharacterString>
							<xsl:for-each select="origin">
								<xsl:value-of select="normalize-space(string(.))"/>
								<xsl:if test="position() != last()">
									<xsl:text>; </xsl:text>
								</xsl:if>
							</xsl:for-each>
						</gco:CharacterString>
					</gmd:organisationName>
					<gmd:contactInfo>
						<gmd:CI_Contact>
							<gmd:address>
								<gmd:CI_Address>
									<gmd:electronicMailAddress gco:nilReason="missing"/>
								</gmd:CI_Address>
							</gmd:address>
						</gmd:CI_Contact>
					</gmd:contactInfo>
					<gmd:role>
						<gmd:CI_RoleCode
							codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
							codeListValue="originator" codeSpace="006"
							>originator</gmd:CI_RoleCode>
					</gmd:role>
				</gmd:CI_ResponsibleParty>
			</gmd:citedResponsibleParty>
			<xsl:if	test="geoform">
				<xsl:variable name="var353_docCode">
					<xsl:call-template name="vmf:docCode">
						<xsl:with-param name="input"	select="translate(normalize-space(string(geoform)), $smallcase, $uppercase)"	/>
					</xsl:call-template>
				</xsl:variable>
				<xsl:variable name="var354_docType">
					<xsl:call-template name="vmf:docType">
						<xsl:with-param name="input"	select="translate(normalize-space(string(geoform)), $smallcase, $uppercase)"	/>
					</xsl:call-template>
				</xsl:variable>
			<gmd:presentationForm>
				<gmd:CI_PresentationFormCode>
					<xsl:attribute name="codeList">
						<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_PresentationFormCode')"/>
					</xsl:attribute>
					<xsl:attribute name="codeListValue">
						<xsl:value-of select="string($var354_docType)"/>
					</xsl:attribute>
					<xsl:attribute name="codeSpace">
						<xsl:value-of select="string($var353_docCode)"/>
					</xsl:attribute>

					<xsl:value-of select="geoform"/>
					</gmd:CI_PresentationFormCode>
			</gmd:presentationForm>
			</xsl:if>
			<xsl:for-each select="serinfo">
				<gmd:series>
					<gmd:CI_Series>
						<xsl:choose>
							<xsl:when test="sername and string-length(sername)>0">
								<gmd:name>
									<gco:CharacterString>
										<xsl:value-of select="string(sername)"/>
									</gco:CharacterString>
								</gmd:name>
							</xsl:when>
							<xsl:otherwise>
								<gmd:name gco:nilReason='missing'/>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:choose>
							<xsl:when test="issue and string-length(issue)>0">
								<gmd:issueIdentification>
									<gco:CharacterString>
										<xsl:value-of select="string(issue)"/>
									</gco:CharacterString>
								</gmd:issueIdentification>
							</xsl:when>
							<xsl:otherwise>
								<gmd:issueIdentification gco:nilReason='missing'/>
							</xsl:otherwise>
						</xsl:choose>
					</gmd:CI_Series>
				</gmd:series>
			</xsl:for-each>
			<xsl:for-each select="othercit">
				<gmd:otherCitationDetails>
					<gco:CharacterString>
						<xsl:value-of select="string(.)"/>
					</gco:CharacterString>
				</gmd:otherCitationDetails>
			</xsl:for-each>
		
	</xsl:template>
	


	<!--  section 1, functions to translate generic codelist terms into ISO codeListValue and codelist code -->
	<xsl:template name="vmf:geometryType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input = 'PIXEL'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input = 'GRID CELL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
			<xsl:when test="$input = 'VOXEL'">
				<xsl:value-of select="'area'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'POINT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'PIXEL'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'GRID CELL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'VOXEL'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryType2">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input = 'ENTITY POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input = 'LABEL POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input = 'AREA POINT'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input = 'NODE, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input = 'NODE, NETWORK'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input = 'STRING'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input = 'LINK'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input = 'COMPLETE CHAIN'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input = 'AREA CHAIN'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input = 'NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input = 'NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input = 'CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input = 'ELLIPTICAL ARC'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input = 'UNIFORM B-SPLINE'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input = 'PIECEWISE BEZIER'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input = 'RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input = 'RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input = 'RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input = 'RING COMPOSED OF ARCS'">
				<xsl:value-of select="'composite'"/>
			</xsl:when>
			<xsl:when test="$input = 'G-POLYGON'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input = 'GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input = 'GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input = 'UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input = 'UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'complex'"/>
			</xsl:when>
			<xsl:when test="$input = 'NODE'">
				<xsl:value-of select="'point'"/>
			</xsl:when>
			<xsl:when test="$input = 'EDGE'">
				<xsl:value-of select="'curve'"/>
			</xsl:when>
			<xsl:when test="$input = 'FACE'">
				<xsl:value-of select="'surface'"/>
			</xsl:when>
			<xsl:when test="$input = 'TEXT'">
				<xsl:value-of select="''"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:geometryCode2">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input = 'ENTITY POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input = 'LABEL POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input = 'AREA POINT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input = 'NODE, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input = 'NODE, NETWORK'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input = 'STRING'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'LINK'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'COMPLETE CHAIN'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'AREA CHAIN'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'NETWORK CHAIN, PLANAR GRAPH'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input = 'NETWORK CHAIN, NONPLANAR GRAPH'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'CIRCULAR ARC, THREE POINT CENTER'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'ELLIPTICAL ARC'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'UNIFORM B-SPLINE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'PIECEWISE BEZIER'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'RING WITH MIXED COMPOSITION'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'RING COMPOSED OF STRINGS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'RING COMPOSED OF CHAINS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'RING COMPOSED OF ARCS'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'G-POLYGON'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'GT-POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'GT-POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'UNIVERSE POLYGON COMPOSED OF RINGS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'UNIVERSE POLYGON COMPOSED OF CHAINS'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:unknown">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:docType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'ATLAS'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input = 'AUDIO'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'DIAGRAM'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'DOCUMENT'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'GLOBE'">
				<xsl:value-of select="'documentHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input = 'MAP'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'PRINTED MAP'">
				<xsl:value-of select="'mapHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input = 'MODEL'">
				<xsl:value-of select="'modelDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'PHYSICAL MODELl'">
				<xsl:value-of select="'modelHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input = 'MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'PROFILE'">
				<xsl:value-of select="'profileDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'CROSS-SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input = 'RASTER DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'SECTION'">
				<xsl:value-of select="'profileHardcopy'"/>
			</xsl:when>
			<xsl:when test="$input = 'SPREADSHEET'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'TABULAR DIGITAL DATA'">
				<xsl:value-of select="'tableDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'VECTOR DIGITAL DATA'">
				<xsl:value-of select="'mapDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'VIDEO'">
				<xsl:value-of select="'videoDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'VIEW'">
				<xsl:value-of select="'imageDigital'"/>
			</xsl:when>
			<xsl:when test="$input = 'DATABASE'">
				<xsl:value-of select="'documentDigital'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:docCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'ATLAS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input = 'AUDIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'DIAGRAM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'DOCUMENT'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'GLOBE'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'MAP'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input = 'PRINTED MAP'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input = 'MODEL'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input = 'PHYSICAL MODELl'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input = 'MULTIMEDIA PRESENTATION'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'PROFILE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input = 'CROSS-SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input = 'RASTER DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input = 'REMOTE-SENSING IMAGE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'SECTION'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input = 'SPREADSHEET'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input = 'TABULAR DIGITAL DATA'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input = 'VECTOR DIGITAL DATA'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input = 'VIDEO'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input = 'VIEW'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'DATABASE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:statusType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'COMPLETED'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input = 'COMPLETE'">
				<xsl:value-of select="'completed'"/>
			</xsl:when>
			<xsl:when test="$input = 'ARCHIVED'">
				<xsl:value-of select="'historicalArchive'"/>
			</xsl:when>
			<xsl:when test="$input = 'OBSOLETE'">
				<xsl:value-of select="'obsolete'"/>
			</xsl:when>
			<xsl:when test="$input = 'ON GOING'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input = 'CONTINUALLY'">
				<xsl:value-of select="'onGoing'"/>
			</xsl:when>
			<xsl:when test="$input = 'PLANNED'">
				<xsl:value-of select="'planned'"/>
			</xsl:when>
			<xsl:when test="$input = 'REQUIRED'">
				<xsl:value-of select="'required'"/>
			</xsl:when>
			<xsl:when test="$input = 'IN PROGRESS'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
			<xsl:when test="$input = 'IN WORK'">
				<xsl:value-of select="'underDevelopment'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:statusCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'COMPLETED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'COMPLETE'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'ARCHIVED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'OBSOLETE'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'ON GOING'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input = 'CONTINUALLY'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input = 'PLANNED'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input = 'REQUIRED'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input = 'IN PROGRESS'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input = 'IN WORK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:updateFrequency">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'CONTINUALLY'">
				<xsl:value-of select="'continual'"/>
			</xsl:when>
			<xsl:when test="$input = 'DAILY'">
				<xsl:value-of select="'daily'"/>
			</xsl:when>
			<xsl:when test="$input = 'WEEKLY'">
				<xsl:value-of select="'weekly'"/>
			</xsl:when>
			<xsl:when test="$input = 'TWO WEEKS'">
				<xsl:value-of select="'fortnightly'"/>
			</xsl:when>
			<xsl:when test="$input = 'MONTHLY'">
				<xsl:value-of select="'monthly'"/>
			</xsl:when>
			<xsl:when test="$input = 'QUARTERLY'">
				<xsl:value-of select="'quarterly'"/>
			</xsl:when>
			<xsl:when test="$input = 'BIANNUALLY'">
				<xsl:value-of select="'biannually'"/>
			</xsl:when>
			<xsl:when test="$input = 'ANNUALLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input = 'YEARLY'">
				<xsl:value-of select="'annually'"/>
			</xsl:when>
			<xsl:when test="$input = 'AS NEEDED'">
				<xsl:value-of select="'asNeeded'"/>
			</xsl:when>
			<xsl:when test="$input = 'IRREGULAR'">
				<xsl:value-of select="'irregular'"/>
			</xsl:when>
			<xsl:when test="$input = 'NOT PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input = 'NONE PLANNED'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:when test="$input = 'UNKNOWN'">
				<xsl:value-of select="'unknown'"/>
			</xsl:when>
			<xsl:when test="$input = 'NONE'">
				<xsl:value-of select="'notPlanned'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'unknown'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:updateFrequencyCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'CONTINUALLY'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'DAILY'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'WEEKLY'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'TWO WEEKS'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input = 'MONTHLY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input = 'QUARTERLY'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input = 'BIANNUALLY'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input = 'ANNUALLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input = 'YEARLY'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input = 'AS NEEDED'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input = 'IRREGULAR'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input = 'NOT PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input = 'NONE PLANNED'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input = 'UNKNOWN'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input = 'NONE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="'012'"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:securityClassType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'CONFIDENTIAL'">
				<xsl:value-of select="'confidential'"/>
			</xsl:when>
			<xsl:when test="$input = 'SECRET'">
				<xsl:value-of select="'secret'"/>
			</xsl:when>
			<xsl:when test="$input = 'TOP SECRET'">
				<xsl:value-of select="'topSecret'"/>
			</xsl:when>
			<xsl:when test="$input = 'UNCLASSIFIED'">
				<xsl:value-of select="'unclassified'"/>
			</xsl:when>
			<xsl:when test="$input = 'RESTRICTED'">
				<xsl:value-of select="'restricted'"/>
			</xsl:when>
			<xsl:when test="$input = 'SECERT'">  <!-- sic, to handle common typo... -->
				<xsl:value-of select="'secret'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:securityClassCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'CONFIDENTIAL'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'SECRET'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input = 'TOP SECRET'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input = 'UNCLASSIFIED'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'RESTRICTED'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'SECERT'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:spatialRepresentationType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'POINT'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input = 'VECTOR'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input = 'RASTER'">
				<xsl:value-of select="'grid'"/>
			</xsl:when>
			<!-- VPF Terms Description: point and vector object information using the 
				terminology and concepts from Department of Defense, 1992, Vector Product 
				Format (MIL-STD-600006) SMR add-->
			<xsl:when test="$input = 'NODE'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input = 'EDGE'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input = 'FACE'">
				<xsl:value-of select="'vector'"/>
			</xsl:when>
			<xsl:when test="$input = 'TEXT'">
				<xsl:value-of select="'textTable'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:spatialRepresentationCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'vector'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'grid'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:mediumType">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'CD-ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input = 'DVD'">
				<xsl:value-of select="'dvd'"/>
			</xsl:when>
			<xsl:when test="$input = 'DVD-ROM'">
				<xsl:value-of select="'dvdRom'"/>
			</xsl:when>
			<xsl:when test="$input = '3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'3halfInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input = '5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'5quarterInchFloppy'"/>
			</xsl:when>
			<xsl:when test="$input = '7-TRACK TAPE'">
				<xsl:value-of select="'7trackTape'"/>
			</xsl:when>
			<xsl:when test="$input = '9-TRACK TAPE'">
				<xsl:value-of select="'9trackType'"/>
			</xsl:when>
			<xsl:when test="$input = '9-TRACK'">
				<xsl:value-of select="'9trackTape'"/>
			</xsl:when>
			<xsl:when test="$input = '3480 CARTRIDGE'">
				<xsl:value-of select="'3480Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input = '3490 CARTRIDGE'">
				<xsl:value-of select="'3490Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input = '3580 CARTRIDGE'">
				<xsl:value-of select="'3580Cartridge'"/>
			</xsl:when>
			<xsl:when test="$input = '4 MM CARTRIDGE'">
				<xsl:value-of select="'4mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input = '8 MM CARTRIDGE'">
				<xsl:value-of select="'8mmCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input = '1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'1quarterInchCartridgeTape'"/>
			</xsl:when>
			<xsl:when test="$input = 'DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'digitalLinearTape'"/>
			</xsl:when>
			<xsl:when test="$input = 'ONLINE'">
				<xsl:value-of select="'onLine'"/>
			</xsl:when>
			<xsl:when test="$input = 'SATELLITE'">
				<xsl:value-of select="'satellite'"/>
			</xsl:when>
			<xsl:when test="$input = 'TELEPHONE LINK'">
				<xsl:value-of select="'telephoneLink'"/>
			</xsl:when>
			<xsl:when test="$input = 'HARDCOPY'">
				<xsl:value-of select="'hardcopy'"/>
			</xsl:when>
			<xsl:when test="$input = 'CD ROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:when test="$input = 'CDROM'">
				<xsl:value-of select="'cdRom'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:mediumCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'CD-ROM'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'DVD'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'DVD-ROM'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = '3-1/2 INCH FLOPPY DISK'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input = '5-1/4 INCH FLOPPY'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input = '7-TRACK TAPE'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input = '9-TRACK TAPE'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input = '9-TRACK'">
				<xsl:value-of select="'007'"/>
			</xsl:when>
			<xsl:when test="$input = '3480 CARTRIDGE'">
				<xsl:value-of select="'008'"/>
			</xsl:when>
			<xsl:when test="$input = '3490 CARTRIDGE'">
				<xsl:value-of select="'009'"/>
			</xsl:when>
			<xsl:when test="$input = '3580 CARTRIDGE'">
				<xsl:value-of select="'010'"/>
			</xsl:when>
			<xsl:when test="$input = '4 MM CARTRIDGE'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input = '8 MM CARTRIDGE'">
				<xsl:value-of select="'012'"/>
			</xsl:when>
			<xsl:when test="$input = '1/4 INCH CARTRIDGE'">
				<xsl:value-of select="'013'"/>
			</xsl:when>
			<xsl:when test="$input = 'DIGITAL LINEAR TAPE'">
				<xsl:value-of select="'014'"/>
			</xsl:when>
			<xsl:when test="$input = 'ONLINE'">
				<xsl:value-of select="'015'"/>
			</xsl:when>
			<xsl:when test="$input = 'SATELLITE'">
				<xsl:value-of select="'016'"/>
			</xsl:when>
			<xsl:when test="$input = 'TELEPHONE LINK'">
				<xsl:value-of select="'017'"/>
			</xsl:when>
			<xsl:when test="$input = 'HARDCOPY'">
				<xsl:value-of select="'018'"/>
			</xsl:when>
			<xsl:when test="$input = 'CD ROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:when test="$input = 'CDROM'">
				<xsl:value-of select="'011'"/>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="''"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:encodingType">
		<!-- this is same as ISO MD_MediumFormatCode, CDSGM recfmt  -->
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'CPIO'">
				<xsl:value-of select="'cpio'"/>
			</xsl:when>
			<xsl:when test="$input = 'TAR'">
				<xsl:value-of select="'tar'"/>
			</xsl:when>
			<xsl:when test="$input = 'HIGH SEIRRA'">
				<xsl:value-of select="'highSierra'"/>
			</xsl:when>
			<xsl:when test="$input = 'ISO 9660'">
				<xsl:value-of select="'iso9660'"/>
			</xsl:when>
			<xsl:when test="$input = 'ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input = 'ISO 9660 UNIX'">
				<xsl:value-of select="'iso9660RockRidge'"/>
			</xsl:when>
			<xsl:when test="$input = 'ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
			<xsl:when test="$input = 'ISO 9660 MAC'">
				<xsl:value-of select="'iso9660AppleHFS'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
	<xsl:template name="vmf:encodingCode">
		<xsl:param name="input"/>
		<xsl:choose>
			<xsl:when test="$input = 'CPIO'">
				<xsl:value-of select="'001'"/>
			</xsl:when>
			<xsl:when test="$input = 'TAR'">
				<xsl:value-of select="'002'"/>
			</xsl:when>
			<xsl:when test="$input = 'HIGH SEIRRA'">
				<xsl:value-of select="'003'"/>
			</xsl:when>
			<xsl:when test="$input = 'ISO 9660'">
				<xsl:value-of select="'004'"/>
			</xsl:when>
			<xsl:when test="$input = 'ISO 9660 WITH ROCK RIDGE'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input = 'ISO 9660 UNIX'">
				<xsl:value-of select="'005'"/>
			</xsl:when>
			<xsl:when test="$input = 'ISO 9660 WITH APPLE HFS'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
			<xsl:when test="$input = 'ISO 9660 MAC'">
				<xsl:value-of select="'006'"/>
			</xsl:when>
		</xsl:choose>
	</xsl:template>
<!--	<xsl:function name="grp:sourcesUsed">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/srcused">
			<xsl:value-of select="string(.)"/>
		</xsl:for-each>
	</xsl:function>
	<xsl:function name="grp:origins">
		<xsl:param name="cur"/>
		<xsl:for-each select="$cur/origin">
			<xsl:value-of select="string(string(.))"/>
		</xsl:for-each>
	</xsl:function>-->
	<!-- end of codelist lookup functions -->
	<!--   ***** -->
	<!-- xml header stuff -->
	<xsl:namespace-alias stylesheet-prefix="gml" result-prefix="#default"/>
	<xsl:output method="xml" encoding="UTF-8" indent="yes"/>

	<!--  ***************** -->
	<!-- Start actual output metadata record here, let's get down to business -->
	<xsl:template match="metadata">
		<gmd:MD_Metadata>
			<xsl:attribute name="xsi:schemaLocation">
				<xsl:value-of
					select="'http://www.isotc211.org/2005/gmd http://schemas.opengis.net/iso/19139/20060504/gmd/gmd.xsd'"
				/>
			</xsl:attribute>
			<xsl:variable name="var_InputRootNode" select="."/>
			<xsl:variable name="var_metadataRoot" select="."/>
			<!-- these all have fixed values for now -->

			<gmd:fileIdentifier>
				<gco:CharacterString>
					<xsl:choose>
						<xsl:when
							test="$var_metadataRoot/idinfo/citation/citeinfo/onlink[1]">
							<xsl:value-of
								select="normalize-space(substring-after(string($var_metadataRoot/idinfo/citation/citeinfo/onlink[1]), '//'))"/>
						</xsl:when>
						<xsl:when test="$var_metadataRoot/distinfo[1]/resdesc">
							<xsl:value-of select="normalize-space(string($var_metadataRoot/distinfo[1]/resdesc))"/>
						</xsl:when>
						<xsl:otherwise>
							<!-- put in something, USGIN profile requires... -->
							<xsl:value-of
								select="concat(string('http://www.opengis.net/def/nil/OGC/0/missing/'), string($currentDateTime))"
							/>
						</xsl:otherwise>
					</xsl:choose>
				</gco:CharacterString>
			</gmd:fileIdentifier>
			<gmd:language>
				<gco:CharacterString>eng</gco:CharacterString>
			</gmd:language>
			<gmd:characterSet>
				<gmd:MD_CharacterSetCode
					codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CharacterSetCode"
					codeListValue="utf8" codeSpace="004">utf8</gmd:MD_CharacterSetCode>
			</gmd:characterSet>
			<gmd:hierarchyLevel>
				<gmd:MD_ScopeCode
					codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode"
					codeListValue="dataset" codeSpace="005">dataset</gmd:MD_ScopeCode>
			</gmd:hierarchyLevel>
			<!-- end fixed values, now start pulling stuff from input record -->
			<gmd:hierarchyLevelName>
				<gco:CharacterString>
					<xsl:value-of select="distinfo/resdesc"/>
				</gco:CharacterString>
			</gmd:hierarchyLevelName>
			<gmd:contact>
				<gmd:CI_ResponsibleParty>
					<!-- scrape input cntinfo for person and org names that might be in one of 2 places -->
					<xsl:apply-templates select="metainfo/metc/cntinfo"/>

					<!-- role gets a fixed value; FGDC doesn't allow for different roles, so assume point of contact -->
					<gmd:role>
						<gmd:CI_RoleCode
							codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
							codeListValue="pointOfContact" codeSpace="007"
							>pointOfContact</gmd:CI_RoleCode>
					</gmd:role>
				</gmd:CI_ResponsibleParty>
			</gmd:contact>
			<gmd:dateStamp>
				<xsl:choose>
					<xsl:when test="metainfo/metd">
						<xsl:variable name="dateFormat">
							<xsl:call-template name="usgin:dateFormat">
								<xsl:with-param name="inputDate" select="normalize-space(string($var_metadataRoot/metainfo/metd[1]))"/>
								<xsl:with-param name="inputTime"/>
							</xsl:call-template>
						</xsl:variable>
						<xsl:choose>
							<xsl:when test="starts-with(string($dateFormat), 'nil')">
								<xsl:attribute name="gco:nilReason">
									<xsl:value-of select="substring-after($dateFormat, 'nil')"/>
								</xsl:attribute>
								<xsl:attribute name="xlink:title">
									<xsl:value-of select="concat(string('Cannot interpret datestring: '), string($var_metadataRoot/metainfo/metd[1]))"/>
								</xsl:attribute>
								<gco:DateTime>1900-01-01T12:00:00</gco:DateTime>
							</xsl:when>
							<xsl:otherwise>
								<gco:DateTime>
								<xsl:value-of select="$dateFormat"/>
								</gco:DateTime>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:when>
					<xsl:otherwise>
						<xsl:attribute name="gco:nilReason">missing</xsl:attribute>
					</xsl:otherwise>
				</xsl:choose>
			</gmd:dateStamp>
			
			<gmd:metadataStandardName>
				<gco:CharacterString>ISO 19139 Geographic Information - Metadata - Implementation Specification</gco:CharacterString>
			</gmd:metadataStandardName>
			<gmd:metadataStandardVersion>
				<gco:CharacterString>2007</gco:CharacterString>
			</gmd:metadataStandardVersion>
			
			<!-- if there is a URL supplied in the citation for the resource, use this as the resource identifier -->
			<gmd:dataSetURI>
				<gco:CharacterString>
					<xsl:choose>
						<xsl:when
							test="$var_metadataRoot/idinfo/citation/citeinfo/onlink[1]">
							<xsl:value-of
								select="normalize-space(string($var_metadataRoot/idinfo/citation/citeinfo/onlink[1]))"
							/>
						</xsl:when>
						<xsl:when test="$var_metadataRoot/distinfo[1]/resdesc">
							<xsl:value-of
								select="normalize-space(string($var_metadataRoot/distinfo[1]/resdesc))"
							/>
						</xsl:when>
						<xsl:otherwise>
							<!-- put in something, USGIN profile requires... -->
							<xsl:value-of
								select="concat(string('http://www.opengis.net/def/nil/OGC/0/missing/'), string($currentDateTime))"
							/>
						</xsl:otherwise>
					</xsl:choose>
				</gco:CharacterString>
			</gmd:dataSetURI>
			<!--/xsl:for-each -->
			<!-- metadata/spdoinfo spatial data information -->
		<xsl:for-each select="spdoinfo">
			<!-- spatial representation -->
			<xsl:for-each select="rastinfo">
				<xsl:variable name="var_rastinfoNode" select="."/>
				<gmd:spatialRepresentationInfo>
					<gmd:MD_GridSpatialRepresentation>
						<xsl:variable name="var_rowCount_exists">
							<xsl:choose>
							<xsl:when test="rowcount">
								<xsl:value-of select="xs:decimal(1)"/>
							</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="xs:decimal(0)"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="var_colCount_exists">
							<xsl:choose>
								<xsl:when test="colcount">
									<xsl:value-of select="xs:decimal(1)"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="xs:decimal(0)"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<xsl:variable name="var_vrtCount_exists">
							<xsl:choose>
								<xsl:when test="vrtcount">
									<xsl:value-of select="xs:decimal(1)"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="xs:decimal(0)"/>
								</xsl:otherwise>
							</xsl:choose>
						</xsl:variable>
						<gmd:numberOfDimensions>
							<xsl:choose>
								<xsl:when
									test="($var_rowCount_exists + $var_colCount_exists + $var_vrtCount_exists) > 0">
									<gco:Integer>
										<xsl:value-of
										select="string(xs:integer($var_rowCount_exists + $var_colCount_exists + $var_vrtCount_exists))"
										/>
									</gco:Integer>
								</xsl:when>
								<xsl:otherwise>
									<gco:Integer>
										<xsl:value-of select="string('1')"/>
									</gco:Integer>
								</xsl:otherwise>
							</xsl:choose>
						</gmd:numberOfDimensions>
						<!-- This for-each and the similar ones below were commented out by Ted Habermann 2011-07-26
							<xsl:for-each select="$var72_metadata/idinfo/citation/citeinfo/lworkcit">-->
						<xsl:if test="$var_rastinfoNode/rowcount">
							<gmd:axisDimensionProperties>
								<gmd:MD_Dimension>
									<gmd:dimensionName>
										<gmd:MD_DimensionNameTypeCode
										codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode"
										codeListValue="row" codeSpace="001"
										>row</gmd:MD_DimensionNameTypeCode>
									</gmd:dimensionName>
									<gmd:dimensionSize>
										<xsl:choose>
											<xsl:when	test="number($var_rastinfoNode/rowcount[1]) != NaN">
												<gco:Integer>
													<xsl:value-of select="xs:integer($var_rastinfoNode/rowcount[1])"/>
												</gco:Integer>
											</xsl:when>
											<xsl:otherwise>
												<xsl:attribute name="gco:nilReason">
													<xsl:value-of select="missing"/>
												</xsl:attribute>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:dimensionSize>
								</gmd:MD_Dimension>
							</gmd:axisDimensionProperties>
						</xsl:if>
						<xsl:if test="$var_rastinfoNode/colcount">
							<gmd:axisDimensionProperties>
								<gmd:MD_Dimension>
									<gmd:dimensionName>
										<gmd:MD_DimensionNameTypeCode
											codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode"
											codeListValue="row" codeSpace="001"
											>row</gmd:MD_DimensionNameTypeCode>
									</gmd:dimensionName>
									<gmd:dimensionSize>
										<xsl:choose>
											<xsl:when	test="number($var_rastinfoNode/colcount[1]) != NaN">
												<gco:Integer>
													<xsl:value-of select="xs:integer($var_rastinfoNode/colcount[1])"/>
												</gco:Integer>
											</xsl:when>
											<xsl:otherwise>
												<xsl:attribute name="gco:nilReason">
													<xsl:value-of select="missing"/>
												</xsl:attribute>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:dimensionSize>
								</gmd:MD_Dimension>
							</gmd:axisDimensionProperties>
						</xsl:if>
						<xsl:if test="$var_rastinfoNode/vrtcount">
							<gmd:axisDimensionProperties>
								<gmd:MD_Dimension>
									<gmd:dimensionName>

										<gmd:MD_DimensionNameTypeCode
										codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_DimensionNameTypeCode"
										codeListValue="vertical" codeSpace="003"
										>vertical</gmd:MD_DimensionNameTypeCode>
									</gmd:dimensionName>
									<gmd:dimensionSize>
										<xsl:choose>
											<xsl:when	test="number($var_rastinfoNode/vrtcount[1]) != NaN">
												<gco:Integer>
													<xsl:value-of select="xs:integer($var_rastinfoNode/vrtcount[1])"/>
												</gco:Integer>
											</xsl:when>
											<xsl:otherwise>
												<xsl:attribute name="gco:nilReason">
													<xsl:value-of select="missing"/>
												</xsl:attribute>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:dimensionSize>
								</gmd:MD_Dimension>
							</gmd:axisDimensionProperties>
						</xsl:if>
						<!--</xsl:for-each>-->
						<!-- determine if input data has a rasttype property and use that to assign cell geometry Type code -->
						<xsl:variable name="var_rasttypeGeometryType">
							<xsl:call-template name="vmf:geometryType">
								<xsl:with-param name="input" select="translate(normalize-space(string(rasttype)), $smallcase, $uppercase)"/>
							</xsl:call-template>
						</xsl:variable>
						<!-- if have gridSpatialRepresnetation, cellGeometry is mandatory -->
						<xsl:choose>
							<xsl:when test="$var_rasttypeGeometryType">
								<gmd:cellGeometry>
									<gmd:MD_CellGeometryCode
										codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_CellGeometryCode">
										<xsl:attribute name="codeListValue">
											<xsl:value-of
										select="string(xs:anyURI($var_rasttypeGeometryType))"
										/>
										</xsl:attribute>
										<xsl:variable name="var_rasttypeGeometryCode">
											<xsl:call-template name="vmf:geometryCode">
												<xsl:with-param name="input"
													select="translate(normalize-space(string(rasttype)), $smallcase, $uppercase)"
										/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:if test="$var_rasttypeGeometryCode">
											<xsl:attribute name="codeSpace">
												<xsl:value-of select="string($var_rasttypeGeometryCode)"/>
											</xsl:attribute>
										</xsl:if>
										<xsl:value-of select="$var_rasttypeGeometryType"/>
									</gmd:MD_CellGeometryCode>
								</gmd:cellGeometry>
							</xsl:when>
							<xsl:otherwise>
								<gmd:cellGeometry gco:nilReason="missing"/>
							</xsl:otherwise>
						</xsl:choose>
						<!-- no content for transformation parmater avaialalbility in FGDC metatada -->
						<gmd:transformationParameterAvailability>
							<xsl:attribute name="gco:nilReason">
								<xsl:value-of select="unknown"/>
							</xsl:attribute>
						</gmd:transformationParameterAvailability>
					</gmd:MD_GridSpatialRepresentation>
				</gmd:spatialRepresentationInfo>
			</xsl:for-each>
			<!-- do vector spatial represntation description; FGCD xml specifies choice between rastinfo or ptvctinf -->
			<!-- but ISO19115 allows both to be present in valid instance -->
			<xsl:for-each select="ptvctinf">
				<!-- Point and Vector Object Information,+ the types and numbers of vector or nongridded point spatial objects in the data set. -->
				<!-- FGDC xml implements this element as a choice between 1..* sdtsterm elements, or 1 vpfterm -->
				<!-- xsl:variable name="var_PointVectorObjCountNode"  select="."/ -->
				<gmd:spatialRepresentationInfo>
					<gmd:MD_VectorSpatialRepresentation>
						<!-- csdgm content is either vpfterm or 1..*stdsterm -->
						<xsl:for-each select="vpfterm">
							<!-- see http://earth-info.nga.mil/publications/specs/printed/2407/2407_VPF.pdf for definition of vpf topology level
							0: boundary representation (spaghetti), nodes and edges; 
							1: non-planar graph nodes, connected nodes, edges
							2: planar graph nodes, connnected nodes, edge
							3: full topology nodes, edges, faces; faces (polygons partition surface
							   -->
							<xsl:variable name="var_vpfTopology">
							<xsl:choose>
								<xsl:when test="vpflevel='0'">
									<xsl:value-of select="string('geometry')"/>
								</xsl:when>
								<xsl:when test="vpflevel='1'">
									<xsl:value-of select="string('topology1D')"/>
								</xsl:when>
								<xsl:when test="vpflevel='2'">
									<xsl:value-of select="string('planarGraph')"/>
								</xsl:when>
								<xsl:when test="vpflevel='3'">
									<xsl:value-of select="string('fullPlanarGraph')"/>
								</xsl:when>
								<xsl:otherwise>
									<xsl:value-of select="string('geometry')"/>
								</xsl:otherwise>
							</xsl:choose>
							</xsl:variable>
							<gmd:topologyLevel>
								<gmd:MD_TopologyLevelCode>
									<xsl:attribute name="codeSpace">
										<xsl:value-of select="string($var_vpfTopology)"/>
									</xsl:attribute>
								</gmd:MD_TopologyLevelCode>
							</gmd:topologyLevel>
							<xsl:for-each select="vpfinfo">
								<xsl:variable name="var_vpfType">
									<xsl:call-template name="vmf:geometryType2">
										<xsl:with-param name="input" select="translate(normalize-space(string(.)), $smallcase, $uppercase)"/>
									</xsl:call-template>
								</xsl:variable>
								<gmd:geometricObjects>
									<gmd:MD_GeometricObjects>
										<gmd:geometricObjectType>
											<gmd:MD_GeometricObjectTypeCode>
												<xsl:attribute name="codeList">
													<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode')"/>
												</xsl:attribute> 
												<xsl:attribute name="codeListValue">
													<xsl:value-of select="$var_vpfType"/>
												</xsl:attribute>
													<xsl:value-of select="normalize-space(string(vpfinfo))"/>
											</gmd:MD_GeometricObjectTypeCode>
										</gmd:geometricObjectType>
										<gmd:geometricObjectCount>
											<gco:Integer>
												<xsl:value-of select="ptvctcnt"/>
											</gco:Integer>
										</gmd:geometricObjectCount>
									</gmd:MD_GeometricObjects>
								</gmd:geometricObjects>
							</xsl:for-each> <!-- vpfinfo -->
						</xsl:for-each> <!-- done with vpfterm processing -->
						<xsl:for-each select="sdtsterm">
							<gmd:geometricObjects>
								<gmd:MD_GeometricObjects>
									<gmd:geometricObjectType>
										<xsl:variable name="var139_sdtsType">
											<xsl:call-template name="vmf:geometryType2">
												<xsl:with-param name="input" select="translate(normalize-space(string(sdtstype)), $smallcase, $uppercase)"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:choose>
											<xsl:when test="$var139_sdtsType">
												<gmd:MD_GeometricObjectTypeCode>
													<xsl:attribute name="codeList">
														<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_GeometricObjectTypeCode')"/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:value-of select="string($var139_sdtsType)" />
													</xsl:attribute>
													<xsl:value-of	select="normalize-space(string(sdtstype))"/>
												</gmd:MD_GeometricObjectTypeCode>
											</xsl:when>
											<xsl:otherwise>
												<xsl:attribute name="gco:nilReason">missing</xsl:attribute>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:geometricObjectType>
									<xsl:if test="ptvctcnt">
									<gmd:geometricObjectCount>
										<gco:Integer>
											<xsl:value-of select="string(ptvctcnt)"/>
										</gco:Integer>
									</gmd:geometricObjectCount>
									</xsl:if>
								</gmd:MD_GeometricObjects>
							</gmd:geometricObjects>
						</xsl:for-each>
					</gmd:MD_VectorSpatialRepresentation>
				</gmd:spatialRepresentationInfo>
			</xsl:for-each>
				<!-- End of ptvctinf-->
		</xsl:for-each>

			<!-- spatial reference system information -->
			<!-- indspref is an indirect spatial reference: any way to describe a location without using coordinates. 
				Indirect spatial reference methods usually use a geographic feature, such as a county, state, township or
section of the Public Land Survey System, or a road, to uniquely identify a place. The reference
may use the name of the feature, for example "Westmoreland County", or a code that identifies the
feature (such as a county FIPS code). Other examples of indirect spatial references include street
addresses, linear reference systems, and River Reach codes. -->
			<!-- this is bogus; what need here is a mappign from =4.1.2.1.1 Map Projection Name - name of the map projection" 
				domain values to EPSG codes -->
			<!-- these are the domain values:
				Albers Conical Equal Area
				Azimuthal Equidistant
				Equidistant Conic
				Equirectangular
				General Vertical Near-sided Perspective Gnomonic
				Lambert Azimuthal Equal Area
				Lambert Conformal Conic
				Mercator
				Modified Stereographic for Alaska
				Miller Cylindrical
				Oblique Mercator
				Orthographic
				Polar Stereographic
				Polyconic
				Robinson
				Sinusoidal
				Space Oblique Mercator
				Stereographic
				Transverse Mercator
				van der Grinten -->

			<!-- metadata extensions FGDC metainfo/metextns/onlink here  -->
			<gmd:metadataExtensionInfo>
				<gmd:MD_MetadataExtensionInformation>
					<gmd:extensionOnLineResource>
						<gmd:CI_OnlineResource>
							<gmd:linkage>
								<gmd:URL>
									<xsl:variable name="CIlinkURL">
										<xsl:value-of select="count(/metadata/metainfo/metextns[1]/onlink)"/>
									</xsl:variable>
									<xsl:for-each select="/metadata/metainfo/metextns[1]/onlink">
										<xsl:value-of
											select="normalize-space(string(.))"/>
										<xsl:if test="($CIlinkURL > 1)">
											<xsl:value-of select="string(' ')"/>
										</xsl:if>
									</xsl:for-each>
									<!--xsl:value-of select="$var_metadataRoot/metainfo/metextns/onlink"/>
										<xsl:value-of select="string(xs:anyURI(normalize-space(string(.))))"/> -->
								</gmd:URL>
							</gmd:linkage>
							<xsl:for-each select="metprof">
								<gmd:name>
									<gco:CharacterString>
										<xsl:value-of select="normalize-space(string(.))"/>
									</gco:CharacterString>
								</gmd:name>
							</xsl:for-each>
						</gmd:CI_OnlineResource>
					</gmd:extensionOnLineResource>
				</gmd:MD_MetadataExtensionInformation>
			</gmd:metadataExtensionInfo>
			<!-- FGDC id metadata/idinfo goes into MD_identification -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:for-each select="idinfo">
					<xsl:variable name="var_idinfoSourceNode" select="."/>
					<gmd:identificationInfo>
						<gmd:MD_DataIdentification>
							<xsl:for-each select="citation">
								<gmd:citation>
									<gmd:CI_Citation>
									<xsl:apply-templates select="citeinfo"/>
									</gmd:CI_Citation>
								</gmd:citation>
							</xsl:for-each>
							<!-- xsl:for-each select="descript/abstract" -->
							<gmd:abstract>
								<gco:CharacterString>
									<xsl:choose>
										<xsl:when
											test="descript/abstract and string-length(string(descript/abstract)) > 0">
											<xsl:value-of select="normalize-space(string(descript/abstract))"/>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="string('no abstract provided')"/>
										</xsl:otherwise>
									</xsl:choose>
		<!-- insert text for spataial data organization, spatial data reference, and entity attribute information
							that is not well accounted for in transformation -->
		<!-- the following text is modified from FGDC_Classic for Web body
An xsl template for displaying metadata in ArcInfo8 with the traditional FGDC look and feel created by mp -->
									Other sections: 
									<xsl:for-each select="$var_metadataRoot/spdoinfo">
										Spatial Data Organization: 
										<xsl:for-each select="indspref">
											Indirect_Spatial_Reference_Method: <xsl:value-of select="."/>
										</xsl:for-each>
										<xsl:for-each select="direct">
											Direct_Spatial_Reference_Method: <xsl:value-of select="."/>
										</xsl:for-each>
										<xsl:for-each select="ptvctinf">
											Point_and_Vector_Object_Information: 
											<xsl:for-each select="sdtsterm"> 
												SDTS_Terms_Description:
												<xsl:for-each select="sdtstype">
													SDTS_Point_and_Vector_Object_Type: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="ptvctcnt">
													Point_and_Vector_Object_Count: <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="vpfterm"> 
												VPF_Terms_Description:
												<xsl:for-each select="vpflevel">
													VPF_Topology_Level: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="vpfinfo">
													VPF_Point_and_Vector_Object_Information:
													<xsl:for-each select="vpftype">
														VPF_Point_and_Vector_Object_Type: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="ptvctcnt">
														Point_and_Vector_Object_Count: <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="rastinfo"> Raster_Object_Information:
											<xsl:for-each select="rasttype"> Raster_Object_Type:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="rowcount"> Row_Count:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="colcount"> Column_Count:
												<xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="vrtcount"> Vertical_Count:
												<xsl:value-of select="."/>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<!-- Spatial Reference text blob gets put in the abstract if its present.-->
									<xsl:for-each select="$var_metadataRoot/spref">
										Spatial_Reference_Information: <xsl:for-each
											select="horizsys">
											Horizontal_Coordinate_System_Definition: <xsl:for-each
												select="geograph"> Geographic: <xsl:for-each
												select="latres"> Latitude_Resolution:
													<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="longres">
												Longitude_Resolution: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="geogunit">
												Geographic_Coordinate_Units: <xsl:value-of
												select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="planar"> Planar: <xsl:for-each
												select="mapproj"> Map_Projection: <xsl:for-each
												select="mapprojn"> Map_Projection_Name:
														<xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="albers">
												Albers_Conical_Equal_Area: </xsl:for-each>
													<xsl:for-each select="azimequi">
												Azimuthal_Equidistant: </xsl:for-each>
													<xsl:for-each select="equicon"> Equidistant_Conic: </xsl:for-each>
													<xsl:for-each select="equirect"> Equirectangular: </xsl:for-each>
													<xsl:for-each select="gvnsp">
												General_Vertical_Near-sided_Perspective: </xsl:for-each>
													<xsl:for-each select="gnomonic"> Gnomonic: </xsl:for-each>
													<xsl:for-each select="lamberta">
												Lambert_Azimuthal_Equal_Area: </xsl:for-each>
													<xsl:for-each select="lambertc">
												Lambert_Conformal_Conic: </xsl:for-each>
													<xsl:for-each select="mercator"> Mercator: </xsl:for-each>
													<xsl:for-each select="modsak">
												Modified_Stereographic_for_Alaska: </xsl:for-each>
													<xsl:for-each select="miller"> Miller_Cylindrical: </xsl:for-each>
													<xsl:for-each select="obqmerc"> Oblique_Mercator: </xsl:for-each>
													<xsl:for-each select="orthogr"> Orthographic: </xsl:for-each>
													<xsl:for-each select="polarst">
												Polar_Stereographic: </xsl:for-each>
													<xsl:for-each select="polycon"> Polyconic: </xsl:for-each>
													<xsl:for-each select="robinson"> Robinson: </xsl:for-each>
													<xsl:for-each select="sinusoid"> Sinusoidal: </xsl:for-each>
													<xsl:for-each select="spaceobq">
												Space_Oblique_Mercator_(Landsat): </xsl:for-each>
													<xsl:for-each select="stereo"> Stereographic: </xsl:for-each>
													<xsl:for-each select="transmer">
												Transverse_Mercator: </xsl:for-each>
													<xsl:for-each select="vdgrin"> van_der_Grinten: </xsl:for-each>
													<xsl:apply-templates select="*"/>
													<!-- this is where the work gets done, in the template for each projection -->
												</xsl:for-each>
												<xsl:for-each select="gridsys">
												Grid_Coordinate_System: <xsl:for-each
												select="gridsysn"> Grid_Coordinate_System_Name:
														<xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="utm">
												Universal_Transverse_Mercator: <xsl:for-each
												select="utmzone"> UTM_Zone_Number: <xsl:value-of
												select="."/>
														</xsl:for-each>
														<xsl:for-each select="transmer">
												Transverse_Mercator: </xsl:for-each>
														<xsl:apply-templates select="transmer"/>
													</xsl:for-each>
													<xsl:for-each select="ups">
												Universal_Polar_Stereographic: <xsl:for-each
												select="upszone"> UPS_Zone_Identifier:
															<xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="polarst">
												Polar_Stereographic: </xsl:for-each>
														<xsl:apply-templates select="polarst"/>
													</xsl:for-each>
													<xsl:for-each select="spcs">
												State_Plane_Coordinate_System: <xsl:for-each
												select="spcszone"> SPCS_Zone_Identifier:
															<xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="lambertc">
												Lambert_Conformal_Conic: </xsl:for-each>
														<xsl:apply-templates select="lambertc"/>
														<xsl:for-each select="transmer">
												Transverse_Mercator: </xsl:for-each>
														<xsl:apply-templates select="transmer"/>
														<xsl:for-each select="obqmerc"> Oblique_Mercator: </xsl:for-each>
														<xsl:apply-templates select="obqmerc"/>
														<xsl:for-each select="polycon"> Polyconic: </xsl:for-each>
														<xsl:apply-templates select="polycon"/>
													</xsl:for-each>
													<xsl:for-each select="arcsys">
												ARC_Coordinate_System: <xsl:for-each
												select="arczone"> ARC_System_Zone_Identifier:
															<xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="equirect"> Equirectangular: </xsl:for-each>
														<xsl:apply-templates select="equirect"/>
														<xsl:for-each select="azimequi">
												Azimuthal_Equidistant: </xsl:for-each>
														<xsl:apply-templates select="azimequi"/>
													</xsl:for-each>
													<xsl:for-each select="othergrd">
												Other_Grid_System's_Definition: <xsl:value-of
												select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="localp"> Local_Planar:
													<xsl:for-each select="localpd">
												Local_Planar_Description: <xsl:value-of select="."
												/>
													</xsl:for-each>
													<xsl:for-each select="localpgi">
												Local_Planar_Georeference_Information:
														<xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="planci">
												Planar_Coordinate_Information: <xsl:for-each
												select="plance">
												Planar_Coordinate_Encoding_Method: <xsl:value-of
												select="."/>
													</xsl:for-each>
													<xsl:for-each select="coordrep">
												Coordinate_Representation: <xsl:for-each
												select="absres"> Abscissa_Resolution:
															<xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="ordres">
												Ordinate_Resolution: <xsl:value-of select="."/>
														</xsl:for-each>
													</xsl:for-each>
													<xsl:for-each select="distbrep">
												Distance_and_Bearing_Representation: <xsl:for-each
												select="distres"> Distance_Resolution:
															<xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearres">
												Bearing_Resolution: <xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearunit"> Bearing_Units:
															<xsl:value-of select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearrefd">
												Bearing_Reference_Direction: <xsl:value-of
												select="."/>
														</xsl:for-each>
														<xsl:for-each select="bearrefm">
												Bearing_Reference_Meridian: <xsl:value-of
												select="."/>
														</xsl:for-each>
													</xsl:for-each>
													<xsl:for-each select="plandu">
												Planar_Distance_Units: <xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="local"> Local: <xsl:for-each
												select="localdes"> Local_Description:
													<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="localgeo">
												Local_Georeference_Information: <xsl:value-of
												select="."/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="geodetic"> Geodetic_Model:
												<xsl:for-each select="horizdn">
												Horizontal_Datum_Name: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="ellips"> Ellipsoid_Name:
													<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="semiaxis"> Semi-major_Axis:
													<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="denflat">
												Denominator_of_Flattening_Ratio: <xsl:value-of
												select="."/>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="vertdef">
											Vertical_Coordinate_System_Definition: <xsl:for-each
												select="altsys"> Altitude_System_Definition:
												<xsl:for-each select="altdatum">
												Altitude_Datum_Name: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="altres"> Altitude_Resolution:
													<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="altunits">
												Altitude_Distance_Units: <xsl:value-of select="."
												/>
												</xsl:for-each>
												<xsl:for-each select="altenc">
												Altitude_Encoding_Method: <xsl:value-of select="."
												/>
												</xsl:for-each>
											</xsl:for-each>
											<xsl:for-each select="depthsys">
												Depth_System_Definition: <xsl:for-each
												select="depthdn"> Depth_Datum_Name: <xsl:value-of
												select="."/>
												</xsl:for-each>
												<xsl:for-each select="depthres"> Depth_Resolution:
													<xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="depthdu">
												Depth_Distance_Units: <xsl:value-of select="."/>
												</xsl:for-each>
												<xsl:for-each select="depthem">
												Depth_Encoding_Method: <xsl:value-of select="."/>
												</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<!-- End spatial reference section -->
									<!-- Entity and Attribute -->
									<xsl:for-each select="$var_metadataRoot/eainfo">
										Entity_and_Attribute_Information: 
										<xsl:for-each	select="detailed"> 
											Detailed_Description: 
												<xsl:for-each select="enttyp"> Entity_Type: 
													<xsl:for-each select="enttypl"> Entity_Label: 
														<xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="enttypd"> Entity_Definition:
														<xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="enttypds"> Definition_Source:
														<xsl:value-of select="."/>
													</xsl:for-each>
												</xsl:for-each>
												<xsl:for-each select="attr"> Attribute: 
													<xsl:for-each select="attrlabl"> Attribute_Label: 
														<xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="attrdef">
														Attribute_Definition: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="attrdefs">
														Attribute_Definition_Source: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="attrdomv">
															Attribute_Domain_Values: 
														<xsl:for-each select="edom"> Enumerated_Domain: 
															<xsl:for-each select="edomv"> 
																Enumerated_Domain_Value: <xsl:value-of select="."/>
															</xsl:for-each>
															<xsl:for-each select="edomvd">
																Enumerated_Domain_Value_Definition: <xsl:value-of select="."/>
															</xsl:for-each>
															<xsl:for-each select="edomvds">
																Enumerated_Domain_Value_Definition_Source:	<xsl:value-of select="."/>
															</xsl:for-each>
															Domain Value Attribute:
															<xsl:apply-templates select="attr"/>
														</xsl:for-each>
													<!-- end enumerated domain -->
														<xsl:for-each select="rdom"> Range_Domain:
															<xsl:for-each select="rdommin">
																Range_Domain_Minimum: <xsl:value-of select="."/>
															</xsl:for-each>
															<xsl:for-each select="rdommax">
																Range_Domain_Maximum: <xsl:value-of select="."/>
															</xsl:for-each>
															<xsl:for-each select="attrunit">
																Attribute_Units_of_Measure: <xsl:value-of select="."/>
															</xsl:for-each>
															<xsl:for-each select="attrmres">
																Attribute_Measurement_Resolution: <xsl:value-of	select="."/>
															</xsl:for-each> 
															Range Domain Attribute:
															<xsl:apply-templates select="attr"/>
														</xsl:for-each>
														<xsl:for-each select="codesetd"> Codeset_Domain:
															<xsl:for-each select="codesetn"> 
																Codeset_Name: <xsl:value-of select="."/>
															</xsl:for-each>
															<xsl:for-each select="codesets"> 
																Codeset_Source:	<xsl:value-of select="."/>
															</xsl:for-each>
														</xsl:for-each>
														<xsl:for-each select="udom">
															Unrepresentable_Domain: <xsl:value-of select="."/>
														</xsl:for-each>
													</xsl:for-each>
													<xsl:for-each select="begdatea">
														Beginning_Date_of_Attribute_Values: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="enddatea">
														Ending_Date_of_Attribute_Values: <xsl:value-of select="."/>
													</xsl:for-each>
													<xsl:for-each select="attrvai">
														Attribute_Value_Accuracy_Information:
															<xsl:for-each select="attrva">
																Attribute_Value_Accuracy: <xsl:value-of select="."/>
															</xsl:for-each>
															<xsl:for-each select="attrvae">
																Attribute_Value_Accuracy_Explanation: <xsl:value-of select="."/>
														`	</xsl:for-each>
													</xsl:for-each>
													<xsl:for-each select="attrmfrq">
														Attribute_Measurement_Frequency: <xsl:value-of select="."/>
													</xsl:for-each>
											</xsl:for-each>
										</xsl:for-each>
										<xsl:for-each select="overview"> Overview_Description:
											<xsl:for-each select="eaover">
												Entity_and_Attribute_Overview: <xsl:value-of select="."/>
											</xsl:for-each>
											<xsl:for-each select="eadetcit">
												Entity_and_Attribute_Detail_Citation: <xsl:value-of	select="."/>
											</xsl:for-each>
										</xsl:for-each>
									</xsl:for-each>
									<!-- end of Entity Attribute section text blob, end of text for abstract element -->
									<!--  /xsl:template -->
								</gco:CharacterString>
							</gmd:abstract>
							<!-- /xsl:for-each -->
							<xsl:for-each select="descript/purpose">
								<gmd:purpose>
									<gco:CharacterString>
										<xsl:value-of select="normalize-space(string(.))"/>
									</gco:CharacterString>
								</gmd:purpose>
							</xsl:for-each>
							<xsl:for-each select="datacred">
								<gmd:credit>
									<gco:CharacterString>
										<xsl:value-of select="normalize-space(string(.))"/>
									</gco:CharacterString>
								</gmd:credit>
							</xsl:for-each>
							<xsl:for-each select="status/progress">
								<!-- Domain: "Complete" "In work" "Planned"  -->
							<gmd:status>
								<gmd:MD_ProgressCode>
										<xsl:attribute name="codeList">
											<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ProgressCode')"/>
										</xsl:attribute>
										<xsl:attribute name="codeListValue">
											<xsl:variable name="var677_result_statusType">
												<xsl:call-template name="vmf:statusType">
													<xsl:with-param name="input"
														select="translate(normalize-space(string(.)), $smallcase, $uppercase)"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:choose>
												<xsl:when	test="$var677_result_statusType">
													<xsl:value-of select="$var677_result_statusType"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="string(.)"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:attribute>
										<xsl:variable name="var392_result_statusCode">
											<xsl:call-template name="vmf:statusCode">
												<xsl:with-param name="input"
													select="translate(normalize-space(string(.)), $smallcase, $uppercase)"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:if	test="$var392_result_statusCode">
											<xsl:attribute name="codeSpace">
												<xsl:value-of select="string($var392_result_statusCode)"/>
											</xsl:attribute>
										</xsl:if>		
										<xsl:value-of select="."/>
									</gmd:MD_ProgressCode>
							</gmd:status>
							</xsl:for-each>
							<xsl:for-each select="ptcontac">
							<gmd:pointOfContact>
								<!-- ptcontac/cntinfo -->
								<xsl:for-each select="cntinfo">
									<!-- xsl:variable name="var_ptcontac-cntinfo_node"  select="."/ -->
									<gmd:CI_ResponsibleParty>
										<xsl:apply-templates select = "."/>
										<gmd:role>
											<gmd:CI_RoleCode>
												<xsl:attribute name="codeList">
													<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode')"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:value-of select="string('pointOfContact')"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:value-of select="string('007')"/>
												</xsl:attribute>
												<xsl:value-of select="'pointOfContact'"/>
											</gmd:CI_RoleCode>
										</gmd:role>
									</gmd:CI_ResponsibleParty>
								</xsl:for-each>
							</gmd:pointOfContact>
							</xsl:for-each>
							<!-- +++ Resource maintenance section -->
							<gmd:resourceMaintenance>
								<gmd:MD_MaintenanceInformation>
									<gmd:maintenanceAndUpdateFrequency>
										<xsl:variable name="var338_updateFrequency">
											<xsl:call-template name="vmf:updateFrequency">
												<xsl:with-param name="input"
													select="translate(normalize-space(string(status/update)), $smallcase, $uppercase)"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:choose>
											<xsl:when test="string-length(var338_updateFrequency)>0">
											<gmd:MD_MaintenanceFrequencyCode>
												<xsl:attribute name="codeList">
													<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode')"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:value-of select="string(var338_updateFrequency)"/>
												</xsl:attribute>
												<xsl:variable	name="var337_updateFrequencyCode">
													<xsl:call-template name="vmf:updateFrequencyCode">
														<xsl:with-param name="input"
															select="translate(normalize-space(string(idinfo/status/update)), $smallcase, $uppercase)"/>
													</xsl:call-template>
												</xsl:variable>
												<xsl:if test="$var337_updateFrequencyCode">
													<xsl:attribute name="codeSpace">
														<xsl:value-of select="string($var337_updateFrequencyCode)"/>
													</xsl:attribute>
												</xsl:if>
												<xsl:value-of select="normalize-space(string(status/update))"/>
											</gmd:MD_MaintenanceFrequencyCode>
											</xsl:when>
											<xsl:otherwise>
												<xsl:attribute name="gco:nilReason">missing</xsl:attribute>
											</xsl:otherwise>
										</xsl:choose>
									</gmd:maintenanceAndUpdateFrequency>
								</gmd:MD_MaintenanceInformation>
							</gmd:resourceMaintenance>
							<xsl:for-each select="$var_metadataRoot/eainfo/detailed/attr/attrmfrq">
								<gmd:resourceMaintenance>
									<gmd:MD_MaintenanceInformation>
										<gmd:maintenanceAndUpdateFrequency>
											<xsl:variable name="var344_updateFrequency">
												<xsl:call-template name="vmf:updateFrequency">
													<xsl:with-param name="input"
														select="translate(normalize-space(string(.)), $smallcase, $uppercase)"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:choose>
											<xsl:when test="$var344_updateFrequency">
												<gmd:MD_MaintenanceFrequencyCode>
													<xsl:attribute name="codeList">
														<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MaintenanceFrequencyCode')"	/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:value-of	select="string($var344_updateFrequency)"/>
													</xsl:attribute>
													<xsl:variable name="var343_updateFrequencyCode">
														<xsl:call-template name="vmf:updateFrequencyCode">
															<xsl:with-param name="input"
																select="translate(normalize-space(string(.)), $smallcase, $uppercase)"/>
														</xsl:call-template>
													</xsl:variable>
													
													<xsl:if	test="$var343_updateFrequencyCode">
														<xsl:attribute name="codeSpace">
															<xsl:value-of	select="string($var343_updateFrequencyCode)"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:value-of select="normalize-space(string(.))"/>
												</gmd:MD_MaintenanceFrequencyCode>
											</xsl:when>
												<xsl:otherwise>
													<xsl:attribute name="gco:nilReason">missing</xsl:attribute>
												</xsl:otherwise>
											</xsl:choose>
										</gmd:maintenanceAndUpdateFrequency>
										<gmd:updateScope>
											<gmd:MD_ScopeCode>
												<xsl:attribute name="codeList">
													<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode')"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:value-of select="string('attribute')"/>
												</xsl:attribute>
											</gmd:MD_ScopeCode>
										</gmd:updateScope>
									</gmd:MD_MaintenanceInformation>
								</gmd:resourceMaintenance>
							</xsl:for-each>
							<!-- Handle browse graphic if it exists -->
							<xsl:for-each select="browse">
								<gmd:graphicOverview>
									<gmd:MD_BrowseGraphic>
										<gmd:fileName>
											<gco:CharacterString>
												<xsl:value-of select="string(browsen)"/>
											</gco:CharacterString>
										</gmd:fileName>
										<xsl:if test="browsed and string-length(browsed)>0">
										<gmd:fileDescription>
											<gco:CharacterString>
												<xsl:value-of select="string(browsed)"/>
											</gco:CharacterString>
										</gmd:fileDescription>
										</xsl:if>
										<xsl:if test="browset and string-length(browset)>0">
										<gmd:fileType>
											<gco:CharacterString>
												<xsl:value-of select="string(browset)"/>
											</gco:CharacterString>
										</gmd:fileType>
										</xsl:if>
									</gmd:MD_BrowseGraphic>
								</gmd:graphicOverview>
							</xsl:for-each>
							
							
	<!-- original keyword handler seems much more complicated than necessary. replace with this -->
							<xsl:for-each select="//keywords/*">
								<xsl:variable name="keywordtype">
									<xsl:choose>
										<xsl:when test="theme">
											<xsl:value-of select="string('theme')"/>
										</xsl:when>
										<xsl:when test="place">
											<xsl:value-of select="string('place')"/>
										</xsl:when>
										<xsl:when test="stratum">
											<xsl:value-of select="string('stratum')"/>
										</xsl:when>
										<xsl:when test="temporal">
											<xsl:value-of select="string('temporal')"/>
										</xsl:when>
									</xsl:choose>
								</xsl:variable>
								
								<gmd:descriptiveKeywords>
									<gmd:MD_Keywords>
										<xsl:for-each select="./*[contains(local-name(), 'key')]">
											<gmd:keyword>
												<gco:CharacterString>
													<xsl:value-of select="normalize-space(string(.))"/>
												</gco:CharacterString>
											</gmd:keyword>
										</xsl:for-each>
										<gmd:type>
											<gmd:MD_KeywordTypeCode>
												<xsl:attribute name="codeList">
													<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_KeywordTypeCode')"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:value-of select="$keywordtype"/>
												</xsl:attribute>
												<xsl:value-of select="$keywordtype"/>
											</gmd:MD_KeywordTypeCode>
										</gmd:type>
										<gmd:thesaurusName>
											<gmd:CI_Citation>
												<gmd:title>
													<gco:CharacterString>
														<xsl:value-of select="normalize-space(./*[contains(local-name(), 'kt')][1])"/>
													</gco:CharacterString>
												</gmd:title>
												<gmd:date>
													<xsl:attribute name="gco:nilReason">
														<xsl:value-of select="string('missing')"/>
													</xsl:attribute>
												</gmd:date>
											</gmd:CI_Citation>
										</gmd:thesaurusName>
									</gmd:MD_Keywords>
								</gmd:descriptiveKeywords>
							</xsl:for-each>					
							
<!-- ***************************************************************************** -->
<!-- resource constraints section, distribution liability, access constraint, and use constraints get concatenated into a single gmd:useConstraint 
								text blob -->
							<xsl:variable name="var_distributionLiability_exists">
								<xsl:if test="$var_metadataRoot/distinfo/distliab">
									<xsl:value-of select="concat('Distribution Liability: ', concat($var_metadataRoot/distinfo/distliab, ' '))"
									/>
								</xsl:if>
							</xsl:variable>
							<xsl:variable name="var_accessConstraints_exists">
								<xsl:if test="accconst">
									<xsl:value-of
										select="concat('Access Constraints: ', concat($var_metadataRoot//idinfo/accconst, ' '))"
									/>
								</xsl:if>
							</xsl:variable>
							<xsl:variable name="var_useLimitation_exists">
								<xsl:if test="useconst">
									<xsl:value-of
										select="concat('Use Limitation: ', concat($var_metadataRoot/idinfo/useconst, ' '))"
									/>
								</xsl:if>
							</xsl:variable>
							<xsl:if
								test="$var_distributionLiability_exists or $var_accessConstraints_exists or $var_useLimitation_exists">
								<gmd:resourceConstraints>
									<gmd:MD_LegalConstraints>
										<xsl:if test="$var_accessConstraints_exists">
											<gmd:accessConstraints>
												<gmd:MD_RestrictionCode
												codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode"
												codeListValue="otherRestrictions" codeSpace="008">
													<xsl:value-of select="'otherRestrictions'"/>
												</gmd:MD_RestrictionCode>
											</gmd:accessConstraints>
										</xsl:if>
										<xsl:if test="$var_useLimitation_exists">
											<gmd:useConstraints>
												<gmd:MD_RestrictionCode
												codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode"
												codeListValue="otherRestrictions" codeSpace="008">
													<xsl:value-of select="'otherRestrictions'"/>
												</gmd:MD_RestrictionCode>
											</gmd:useConstraints>
										</xsl:if>
										<gmd:otherConstraints>
											<gco:CharacterString>
												<xsl:value-of
												select="normalize-space(concat($var_accessConstraints_exists, ' ', $var_useLimitation_exists, ' ', $var_distributionLiability_exists))"
												/>
											</gco:CharacterString>
										</gmd:otherConstraints>
									</gmd:MD_LegalConstraints>
								</gmd:resourceConstraints>
							</xsl:if>
							<xsl:for-each select="secinfo">
								<gmd:resourceConstraints>
									<gmd:MD_SecurityConstraints>
										<gmd:classification>
											<xsl:variable name="var388_securityClassType">
												<xsl:call-template name="vmf:securityClassType">
													<xsl:with-param name="input"
														select="translate(normalize-space(string(secclass)), $smallcase, $uppercase)"/>
												</xsl:call-template>
											</xsl:variable>
											<xsl:choose>
											<xsl:when test="$var388_securityClassType">
												<gmd:MD_ClassificationCode>
													<xsl:attribute name="codeList">
														<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode')"/>
													</xsl:attribute>
													<xsl:attribute name="codeListValue">
														<xsl:value-of select="string($var388_securityClassType)"/>
													</xsl:attribute>
													<xsl:variable	name="var387_securityClassCode">
														<xsl:call-template name="vmf:securityClassCode">
															<xsl:with-param name="input"
																select="translate(normalize-space(string(secclass)), $smallcase, $uppercase)"/>
														</xsl:call-template>
													</xsl:variable>
												
													<xsl:if
														test="$var387_securityClassCode">
														<xsl:attribute name="codeSpace">
															<xsl:value-of select="string($var387_securityClassCode)"/>
														</xsl:attribute>
													</xsl:if>
													<xsl:value-of select="normalize-space(string(secclass))"/>
												</gmd:MD_ClassificationCode>
											</xsl:when>
												<xsl:otherwise>
													<xsl:attribute name="gco:nilReason">missing</xsl:attribute>
												</xsl:otherwise>
											</xsl:choose>
										</gmd:classification>
										<gmd:classificationSystem>
											<gco:CharacterString>
												<xsl:value-of select="string(secsys)"/>
											</gco:CharacterString>
										</gmd:classificationSystem>
										<gmd:handlingDescription>
											<gco:CharacterString>
												<xsl:value-of select="string(sechandl)"/>
											</gco:CharacterString>
										</gmd:handlingDescription>
									</gmd:MD_SecurityConstraints>
								</gmd:resourceConstraints>
							</xsl:for-each>

							<!--  put in relationships to larger work and cross references using gmd:aggregationInfo elements -->
							<xsl:for-each select="citation/citeinfo/lworkcit">
								<xsl:variable name="var_largerWorkCitationNode" select="."/>
								<gmd:aggregationInfo>
									<gmd:MD_AggregateInformation>
										<gmd:aggregateDataSetName>
											<gmd:CI_Citation>
											<xsl:apply-templates select="citeinfo"/>
											</gmd:CI_Citation>
										</gmd:aggregateDataSetName>
										<gmd:associationType>
											<!-- xsl:variable name="var688_cond_result_exists" select="(if (exists(citeinfo/origin)) then 'largerWorkCitation' else ())"/>
											<xsl:if test="exists($var688_cond_result_exists)" -->
											<gmd:DS_AssociationTypeCode
											codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode"
											codeListValue="largerWorkCitation" codeSpace="002">
												<!--xsl:variable name="var689_cond_result_exists">
														<xsl:if test="exists(citeinfo/origin)">
															<xsl:variable name="var691_cond_result_exists" select="(if (exists(citeinfo/origin)) then 'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode' else ())"/>
															<xsl:if test="exists($var691_cond_result_exists)">
																<xsl:value-of select="$var691_cond_result_exists"/>
															</xsl:if>
														</xsl:if>
													</xsl:variable>
													<xsl:if test="exists($var689_cond_result_exists)">
														<xsl:attribute name="codeList"><xsl:value-of select="string(xs:anyURI($var689_cond_result_exists))"/></xsl:attribute>
													</xsl:if>
													<xsl:attribute name="codeListValue"><xsl:value-of select="string(xs:anyURI($var688_cond_result_exists))"/></xsl:attribute>
													<xsl:variable name="var692_cond_result_exists" select="(if (exists(citeinfo/origin)) then '002' else ())"/>
													<xsl:if test="exists($var692_cond_result_exists)">
														<xsl:attribute name="codeSpace"><xsl:value-of select="string(xs:anyURI($var692_cond_result_exists))"/></xsl:attribute>
													</xsl:if -->
												<xsl:value-of select="largerWorkCitation"/>
											</gmd:DS_AssociationTypeCode>
											<!--/xsl:if -->
										</gmd:associationType>
									</gmd:MD_AggregateInformation>
								</gmd:aggregationInfo>
							</xsl:for-each>
						
							<xsl:if test="crossref">
		<!-- Cross Reference: information about other, related data sets that are likely to be of interest. -->
								<!-- cardinality 0..* on idinfo; put in gmd:aggregationInfo; if there is a larger workcitation, put that in 
								Other citation information here, with title in collective work title.-->
								<xsl:for-each select="crossref">
									<gmd:aggregationInfo>
										<gmd:MD_AggregateInformation>
											<gmd:aggregateDataSetName>
												<gmd:CI_Citation>
												<xsl:apply-templates select="citeinfo"/>
												</gmd:CI_Citation>
											</gmd:aggregateDataSetName>
											<!-- /xsl:for-each -->
											<gmd:associationType>
											<gmd:DS_AssociationTypeCode>
												<xsl:attribute name="codeList">
													<xsl:value-of select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#DS_AssociationTypeCode')"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:value-of select="string('crossReference')"/>
												</xsl:attribute>
												<xsl:attribute name="codeSpace">
													<xsl:value-of select="string('001')"/>
												</xsl:attribute>
												<xsl:value-of select="string('crossReference')"/>
											</gmd:DS_AssociationTypeCode>
											</gmd:associationType>
										</gmd:MD_AggregateInformation>
									</gmd:aggregationInfo>
								</xsl:for-each>
							</xsl:if>

							<!-- ******************************************************************************************************************* -->
							<!-- Spatial Representation -->
							<xsl:for-each select="$var_metadataRoot/spdoinfo">
								<gmd:spatialRepresentationType>
									<xsl:for-each select="direct">
										<xsl:variable name="var563_spatialRepresentationType">
											<xsl:call-template name="vmf:spatialRepresentationType">
												<xsl:with-param name="input"
												select="translate(normalize-space(string(.)),$smallcase,$uppercase)"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:variable name="var564_spatialRepresentationCode">
											<xsl:call-template name="vmf:spatialRepresentationCode">
												<xsl:with-param name="input" select="$var563_spatialRepresentationType"/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:choose>
										<xsl:when	test="$var563_spatialRepresentationType">
											<gmd:MD_SpatialRepresentationTypeCode>
												<xsl:attribute name="codeList">
													<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_SpatialRepresentationTypeCode')"/>
												</xsl:attribute>
												<xsl:attribute name="codeListValue">
													<xsl:value-of select="string($var563_spatialRepresentationType)"/>
												</xsl:attribute>
												<xsl:if test="$var564_spatialRepresentationCode">
													<xsl:attribute name="codeSpace">
														<xsl:value-of select="string($var564_spatialRepresentationCode)"/>
													</xsl:attribute>
												</xsl:if>
												<xsl:value-of select="normalize-space(string(.))"/>
											</gmd:MD_SpatialRepresentationTypeCode>
										</xsl:when>
											<xsl:otherwise>
												<xsl:attribute name="gco:nilReason">missing</xsl:attribute>
											</xsl:otherwise>
										</xsl:choose>
									</xsl:for-each>
								</gmd:spatialRepresentationType>
							</xsl:for-each>
							<!-- resource language -->
							<gmd:language>
								<gco:CharacterString>
									<xsl:value-of select="'eng'"/>
								</gco:CharacterString>
							</gmd:language>
							<!-- messy logic to check if is present ISO topic category, allowing for multiple values  -->
							
							<xsl:for-each select="keywords/theme">
								<xsl:for-each select="themekey">
									<xsl:if
										test="contains('biota boundaries climatologyMeteorologyAtmosphere 
										economy elevation environment farming geoscientificInformation 
										health imageryBaseMapsEarthCover inlandWaters intelligenceMilitary 
										location oceans planningCadastre society structure transportation 
										utilitiesCommunication', normalize-space(string(.)))">
										<!-- accumulate topic elements in hasISOtopic variable -->
										<gmd:topicCategory>
											<gmd:MD_TopicCategoryCode>
												<xsl:value-of select="string(.)"/>
											</gmd:MD_TopicCategoryCode>
										</gmd:topicCategory>
									</xsl:if>
								</xsl:for-each>
							</xsl:for-each>
								
							<!-- end topic category section -->

							<xsl:if test="$var_metadataRoot/native or $var_metadataRoot/distinfo/techpreq">
								<gmd:environmentDescription>
									<gco:CharacterString>
											<xsl:if test ="$var_metadataRoot/distinfo/techpreq">
												<xsl:value-of select="string(' Technical Prerequisites: ')"/>
											</xsl:if>
											<xsl:for-each select="$var_metadataRoot/distinfo/techpreq">
												<xsl:value-of select="string(.)"/>
												<xsl:if test="position() != last()">
													<xsl:text>; </xsl:text>
												</xsl:if>
											</xsl:for-each>
											<xsl:if test="$var_metadataRoot/native">
												<xsl:value-of select="concat('Native Dataset Environment: ', string($var_metadataRoot/native))"/>
											</xsl:if>
										</gco:CharacterString>
								</gmd:environmentDescription>
							</xsl:if>

							<!-- Extent section, geographic, vertical, temporal... -->
							<gmd:extent>
								<gmd:EX_Extent>
									<xsl:attribute name="id">
										<xsl:value-of select="generate-id()"/>
									</xsl:attribute>
									<gmd:geographicElement>
										<!-- bounding box is mandatory, spatial reference should be EPSG 4326, ie WGS 84 -->
										<!-- geographic extent, lat long bounding box required for USGIN -->
										<gmd:EX_GeographicBoundingBox>
											<xsl:attribute name="id">
												<xsl:value-of
												select="concat('gbb.', generate-id())"/>
											</xsl:attribute>
											<gmd:westBoundLongitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when test="number(spdom/bounding/westbc) != NaN">
															<xsl:value-of
												select="string(xs:decimal(spdom/bounding/westbc))"
												/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="string(-179.9)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:westBoundLongitude>
											<gmd:eastBoundLongitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when
												test="number(spdom/bounding/eastbc) != NaN">
															<xsl:value-of
												select="string(xs:decimal(spdom/bounding/eastbc))"
												/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="string(-60)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:eastBoundLongitude>
											<gmd:southBoundLatitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when
												test="number(spdom/bounding/southbc) != NaN">
															<xsl:value-of
												select="string(xs:decimal(spdom/bounding/southbc))"
												/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="string(14)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:southBoundLatitude>
											<gmd:northBoundLatitude>
												<gco:Decimal>
													<xsl:choose>
														<xsl:when
												test="number(spdom/bounding/northbc) != NaN">
															<xsl:value-of
												select="string(xs:decimal(spdom/bounding/northbc))"
												/>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="string(170)"/>
														</xsl:otherwise>
													</xsl:choose>
												</gco:Decimal>
											</gmd:northBoundLatitude>
										</gmd:EX_GeographicBoundingBox>
									</gmd:geographicElement>
									<xsl:for-each select="spdom/dsgpoly">
										<gmd:geographicElement>
											<!-- handle extent encoded as a polygon -->
											<xsl:variable name="var582_dsgpoly" select="."/>
											<gmd:EX_BoundingPolygon>
												<gmd:polygon>
													<gml:Polygon>
														<xsl:attribute name="gml:id">
															<xsl:value-of select="concat('boundingPoly.', generate-id())"/>
														</xsl:attribute>
														<gml:interior>
															<gml:LinearRing>
																<gml:coordinates>
																		<xsl:for-each select="dsgpolyo/grngpoin">
																			<xsl:value-of select="concat(string(gringlat), ', ', string(gringlon))"/>
																			<xsl:if test="position() != last()">
																				<xsl:text>; </xsl:text>
																			</xsl:if>
																		</xsl:for-each>
																	
<!--																	<xsl:variable name="var584_cond_result_exists">
																		<xsl:choose>
																			<xsl:when test="$var587_map_select_grngpoin">
																				<xsl:for-each select="dsgpolyo/grngpoin">
																					<xsl:value-of select="concat(string(gringlat), ', ', string(gringlon), '; ')"/>
																				</xsl:for-each>
																			</xsl:when>
																			<xsl:otherwise>
																				<xsl:for-each select="dsgpolyo/gring">
																					<xsl:value-of select="string(.)"/>
																				</xsl:for-each>
																			</xsl:otherwise>
																		</xsl:choose>
																	</xsl:variable>
																	<xsl:for-each select="$var584_cond_result_exists">
																		<xsl:attribute name="decimal">
																			<xsl:value-of select="normalize-space(.)"/>
																		</xsl:attribute>
																	</xsl:for-each>-->
																</gml:coordinates>
															</gml:LinearRing>
														</gml:interior>
													</gml:Polygon>
												</gmd:polygon>
											</gmd:EX_BoundingPolygon>
										</gmd:geographicElement>
									</xsl:for-each>
									<!-- temporal extent, single date -->
									<xsl:for-each select="timeperd/timeinfo/sngdate">
										<xsl:variable name="var_extentSingleDate" select="."/>
										<gmd:temporalElement>
											<gmd:EX_TemporalExtent>
												<xsl:attribute name="id">
													<xsl:value-of select="concat('TempEx.', generate-id())"/>
												</xsl:attribute>
												<gmd:extent>
													<xsl:if test="(contains(string(caldate), 'unknown') or contains(string(caldate), 'unpublished'))">
														<xsl:attribute name="gco:nilReason">
															<xsl:value-of select="normalize-space(string(caldate))" />
														</xsl:attribute>
													</xsl:if>
													<gml:TimeInstant>
														<xsl:attribute name="gml:id">
															<xsl:value-of select="concat('TInst.', generate-id())"/>
														</xsl:attribute>
														<gml:description>
															<xsl:value-of select="string($var_metadataRoot/idinfo/timeperd/current)"/>
														</gml:description>
														<!-- now process the dates -->
														<!--						<xsl:variable name="var_DateTemp" > -->
														<xsl:variable name="var_TimePos">
															<xsl:call-template name="usgin:TimePositionFormat">
																<xsl:with-param name="inputDate" select="(caldate)"/>
																<xsl:with-param name="inputTime" select="(time)"/>
															</xsl:call-template>
														</xsl:variable>
														<gml:timePosition>
															<xsl:choose>
																<xsl:when test="(substring($var_TimePos, 5, 1) = '-') and (substring($var_TimePos, 8, 1) = '-')">
																	<xsl:value-of select="$var_TimePos"/>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:value-of select="string('unknown')"/>
																	</xsl:attribute>
																</xsl:otherwise>
															</xsl:choose>
														</gml:timePosition>
														<!-- /xsl:for-each -->
													</gml:TimeInstant>
												</gmd:extent>
											</gmd:EX_TemporalExtent>
										</gmd:temporalElement>
									</xsl:for-each>
									<!-- temmporal extent, multiple individual dates and times. 
						 guess the idea is there might be multple mdattim/sngdate elements?-->
									<xsl:for-each select="timeperd/timeinfo/mdattim/sngdate">
										<xsl:variable name="var713_sngdate" select="."/>
										<gmd:temporalElement>
											<gmd:EX_TemporalExtent>
												<xsl:attribute name="id">
													<xsl:value-of select="concat('TimePeriodEx.', generate-id())" />
												</xsl:attribute>
												<gmd:extent>
													<xsl:if test="(contains(string(caldate), 'unknown') or 
														contains(string(caldate), 'unpublished'))">
														<xsl:attribute name="gco:nilReason">
															<xsl:value-of select="normalize-space(string(caldate))"/>
														</xsl:attribute>
													</xsl:if>
													<gml:TimeInstant>
														<xsl:attribute name="gml:id">
															<xsl:value-of	select="concat('ATimeInstant.', generate-id())"	/>
														</xsl:attribute>
														<gml:description>
															<xsl:value-of select="string(string($var_metadataRoot/idinfo/timeperd/current))"/>
														</gml:description>
														<gml:timePosition>
															<xsl:choose>
																<xsl:when	test="contains(string(caldate), 'resent') ">
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:value-of select="string('now')"/>
																	</xsl:attribute>
																</xsl:when>
																<xsl:when	test="contains(string(caldate), 'nknown') ">
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:value-of select="string('unknown')"/>
																	</xsl:attribute>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:choose>
																		<xsl:when test="caldate">
																			<xsl:variable name="dateFormat">
																				<xsl:call-template name="usgin:dateFormat">
																					<xsl:with-param name="inputDate" select="normalize-space(string(caldate))"/>
																					<xsl:with-param name="inputTime" select="normalize-space(string(time))"/>
																				</xsl:call-template>
																			</xsl:variable>
																			<xsl:choose>
																				<xsl:when test="starts-with(string($dateFormat), 'nil')">
																					<xsl:attribute name="indeterminatePosition">
																						<xsl:value-of select="'unknown'"/>
																					</xsl:attribute>
																					<xsl:attribute name="calendarEraName">
																						<xsl:value-of select="concat(string('Cannot interpret datestring: '), caldate, 'T: ', time)"/>
																					</xsl:attribute>
																				</xsl:when>
																				<xsl:otherwise>
																					<gco:DateTime>
																						<xsl:value-of select="$dateFormat"/>
																					</gco:DateTime>
																				</xsl:otherwise>
																			</xsl:choose>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:attribute name="indeterminatePosition">unknown</xsl:attribute>
																		</xsl:otherwise>
																	</xsl:choose>																
																</xsl:otherwise>
															</xsl:choose>
														</gml:timePosition>
													</gml:TimeInstant>
												</gmd:extent>
											</gmd:EX_TemporalExtent>
										</gmd:temporalElement>
									</xsl:for-each>
									<!-- temporal extent, range of dates and time -->
									<!-- each rngdates has a rngdates/begdate begtime, and /enddate /endtime -->
									<xsl:for-each select="timeperd/timeinfo/rngdates">
										<xsl:variable name="var_rngdatesNode" select="."/>
										<gmd:temporalElement>
											<xsl:if
												test="contains(string(begdate), 'unknown') or contains(string(begdate), 'unpublished')">
												<xsl:attribute name="gco:nilReason">
													<xsl:value-of select="normalize-space(string(begdate))"	/>
												</xsl:attribute>
											</xsl:if>
											<gmd:EX_TemporalExtent>
												<xsl:attribute name="id">
													<xsl:value-of	select="concat('DateRngEx.', generate-id())"/>
												</xsl:attribute>
												<gmd:extent>
													<gml:TimePeriod>
														<xsl:attribute name="gml:id">
															<xsl:value-of select="concat('bndTimePeriod.', generate-id())"/>
														</xsl:attribute>
														<gml:description>
															<xsl:value-of select="string($var_metadataRoot/idinfo/timeperd/current)" />
														</gml:description>
														<gml:beginPosition>
															
															<!-- xsl:value-of select="string(string(.))"/ -->
															<!-- can't use template because that puts date in a gco:DateTime elment, but needs to be gml:TimePosition here -->
															<xsl:variable name="dateFormat">
																<xsl:call-template name="usgin:dateFormat">
																	<xsl:with-param name="inputDate" select="(begdate)"/>
																	<xsl:with-param name="inputTime" select="(begtime)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:choose>
																<xsl:when	test="contains(string(begdate), 'present')">
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:value-of	select="string('now')"/>
																	</xsl:attribute>
																</xsl:when>
																<xsl:when test="starts-with(string($dateFormat), 'nil')">
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:value-of select="'unknown'"/>
																	</xsl:attribute>
																	<xsl:attribute name="calendarEraName">
																		<xsl:value-of select="concat(string('Cannot interpret datestring: '), begdate, 'T: ', begtime)"/>
																	</xsl:attribute>
																</xsl:when>
																<xsl:when test="$dateFormat">
																		<xsl:value-of select="$dateFormat"/>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:value-of select="'unknown'"/>
																	</xsl:attribute>
																</xsl:otherwise>
															</xsl:choose>
										
														</gml:beginPosition>
														<!-- /xsl:for-each -->
														<gml:endPosition>
															
															<xsl:variable name="dateFormat">
																<xsl:call-template name="usgin:dateFormat">
																	<xsl:with-param name="inputDate" select="(enddate)"/>
																	<xsl:with-param name="inputTime" select="(endtime)"/>
																</xsl:call-template>
															</xsl:variable>
															<xsl:choose>
																<xsl:when test="contains(string($var_rngdatesNode/enddate), 'present')">
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:value-of select="string('now')"/>
																	</xsl:attribute>
																</xsl:when>
																<xsl:when test="starts-with(string($dateFormat), 'nil')">
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:value-of select="'unknown'"/>
																	</xsl:attribute>
																	<xsl:attribute name="calendarEraName">
																		<xsl:value-of select="concat(string('Cannot interpret datestring: '), enddate, 'T: ', endtime)"/>
																	</xsl:attribute>
																</xsl:when>
																<xsl:when test="$dateFormat">
																		<xsl:value-of select="$dateFormat"/>
																</xsl:when>
																<xsl:otherwise>
																	<xsl:attribute name="indeterminatePosition">
																		<xsl:value-of select="'unknown'"/>
																	</xsl:attribute>
																</xsl:otherwise>
															</xsl:choose>
														</gml:endPosition>
													</gml:TimePeriod>
												</gmd:extent>
											</gmd:EX_TemporalExtent>
										</gmd:temporalElement>
									</xsl:for-each>
								</gmd:EX_Extent>
							</gmd:extent>
							<!-- supplemental information text blob... -->
							<xsl:for-each select="descript/supplinf">
								<gmd:supplementalInformation>
									<gco:CharacterString>
										<xsl:value-of select="string(.)"/>
									</gco:CharacterString>
								</gmd:supplementalInformation>
							</xsl:for-each>
						</gmd:MD_DataIdentification>
					</gmd:identificationInfo>
				</xsl:for-each>
			</xsl:for-each>
			
			
			<!-- content information section -->
			<!-- In ISO, attribute information is represented in a feature catalogue; in this transform, 
				the full entity-attribute description is placed as text in the abstract if present			-->
			<!-- eainfo (0..1) in CSDGM must have at least 1 of either a detailed element or an overview element -->
			<!-- in CSDGM, if there are multiple entities with different attributes, each entity is represented as a separate
				detailed element; each of these detailed element can have a different source citation. A source citation
				can also appear in an overview section. all of these citations are loaded into MD_FeatureCatalogueDescription/
				featureCatalogueCitation elements -->
			<xsl:if test="$var_metadataRoot/eainfo">
				<gmd:contentInfo>
<!-- generate a feature catalogue description -->
					<gmd:MD_FeatureCatalogueDescription>
						<gmd:includedWithDataset>
							<gco:Boolean>
								<xsl:choose>
								<xsl:when test="$var_metadataRoot/eainfo/detailed">
									<xsl:value-of select ="string('true')"/>
								</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="string('false')"/>
									</xsl:otherwise>
								</xsl:choose>
							</gco:Boolean>
						</gmd:includedWithDataset>
						<xsl:for-each select="$var_metadataRoot/eainfo/detailed/enttyp">
							<!-- a sequence listing all the entity types using enttypl, 
							if there is an enttypd, it will be in the abstract in the ISO metadata-->
							<gmd:featureTypes>
								<gco:LocalName>
									<xsl:attribute name="codeSpace">
										<xsl:value-of select="normalize-space(string(enttypl))"/>
									</xsl:attribute>
								</gco:LocalName>
							</gmd:featureTypes>
						</xsl:for-each>
							<!-- ISO19115 requires at least one citation in MD_FeatureCatalogueDescription -->
							<!-- CSDGM overview information goes in citation details. -->

							<xsl:choose>
								<xsl:when test="not($var_metadataRoot/eainfo//enttypds or $var_metadataRoot/eainfo//eadetcit)">
									<xsl:element name="gmd:featureCatalogueCitation">
									<xsl:attribute name="gco:nilReason">
										<xsl:value-of select="string('missing')"/>
									</xsl:attribute>
									</xsl:element>
								</xsl:when>
							<xsl:otherwise>
			
								<xsl:for-each select="$var_metadataRoot/eainfo//enttypds">
									<!-- this will generate a citation for each entity type; 
									elegant solution would group by source and list all the entities
									for that source in the otherCitationDetails. TBD...-->
									<gmd:featureCatalogueCitation>
										<gmd:CI_Citation>
											<gmd:title>
												<gco:CharacterString>
													<xsl:value-of select="normalize-space(string(.))"/>
												</gco:CharacterString>
											</gmd:title>
											<gmd:date>
												<xsl:attribute name="gco:nilReason">
													<xsl:value-of select="string('missing')"/>
												</xsl:attribute>
											</gmd:date>
											<gmd:otherCitationDetails>
												<gco:CharacterString>
													<xsl:value-of
														select="concat(string('Source for entity: '), normalize-space(string(preceding-sibling::enttypl)) )"/>
												</gco:CharacterString>
											</gmd:otherCitationDetails>
										</gmd:CI_Citation>
									</gmd:featureCatalogueCitation>
								</xsl:for-each>
								<xsl:for-each select="$var_metadataRoot/eainfo/overview/eadetcit">
									<!-- CSDGM overview information goes in citation details. -->
									<gmd:featureCatalogueCitation>
										<gmd:CI_Citation>
										<gmd:title>
											<gco:CharacterString>
												<xsl:value-of select="normalize-space(string(.))"/>
											</gco:CharacterString>
										</gmd:title>
										<gmd:date>
											<xsl:attribute name="gco:nilReason">
												<xsl:value-of select="string('missing')"/>
											</xsl:attribute>
										</gmd:date>
										<xsl:if test="preceding-sibling::eaover">
											<gmd:otherCitationDetails>
												<gco:CharacterString>
													<xsl:value-of
														select="concat(string('Overview for this source: '), normalize-space(string(preceding-sibling::eaover)) )"/>
												</gco:CharacterString>
											</gmd:otherCitationDetails>
										</xsl:if>
										</gmd:CI_Citation>
									</gmd:featureCatalogueCitation>
								</xsl:for-each>
							</xsl:otherwise>
							</xsl:choose>
						
					</gmd:MD_FeatureCatalogueDescription>
				</gmd:contentInfo>
			</xsl:if>
			<!-- image description in separate content info element -->
			<xsl:if test="$var_metadataRoot/dataqual/cloud">
				<gmd:contentInfo>
					<gmd:MD_ImageDescription>
						<!-- attributDescription and contentType are mandatory in ISO19115 -->
						<gmd:attributeDescription gco:nilReason="missing"/>
						<gmd:contentType>
							<gmd:MD_CoverageContentTypeCode codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_CoverageContentTypeCode" codeListValue="image"/>
						</gmd:contentType>
					
						<gmd:cloudCoverPercentage>
							<xsl:choose>
								<xsl:when
									test="contains(translate(string($var_metadataRoot/dataqual/cloud),$uppercase,$smallcase), 'unknown')">
									<xsl:attribute name="gco:nilReason">
										<xsl:value-of select="string('unknown')"/>
									</xsl:attribute>
								</xsl:when>
								<xsl:when test="number($var_metadataRoot/dataqual/cloud[1]) != NaN">
									<gco:Real>
										<xsl:value-of select="number($var_metadataRoot/dataqual/cloud[1])"/>
									</gco:Real>
								</xsl:when>
								<xsl:otherwise>
									<xsl:attribute name="gco:nilReason">
										<xsl:value-of select="string('missing')"/>
									</xsl:attribute>
								</xsl:otherwise>
							</xsl:choose>
						</gmd:cloudCoverPercentage>
					</gmd:MD_ImageDescription>
				</gmd:contentInfo>
			</xsl:if>
				
				<!-- for FGDC record, assume only a single distribution distributor/transferOption/format will be specified -->
			<gmd:distributionInfo>
				<gmd:MD_Distribution>
					<xsl:for-each select="$var_metadataRoot/distinfo/stdorder/digform">
						<xsl:variable name="var1090_digform" select="."/>
						<!-- distribution format -->
						<gmd:distributionFormat>
							<gmd:MD_Format>
								<gmd:name>
									<gco:CharacterString>
										<xsl:value-of
											select="normalize-space(string(digtinfo/formname))"
										/>
									</gco:CharacterString>
								</gmd:name>
								<gmd:version>
									
										<xsl:choose>
											<xsl:when test="$var1090_digform/digtinfo/formvern">
												<xsl:for-each select="digtinfo/formvern">
													<xsl:if	test="not(contains(string(.),'unknown'))">
														<gco:CharacterString>
														<xsl:value-of select="string(.)"/>
														</gco:CharacterString>
													</xsl:if>	
												</xsl:for-each>
											</xsl:when>
											<xsl:otherwise>
												<xsl:attribute name="gco:nilReason">
													<xsl:value-of select="string('unknown')"/>
												</xsl:attribute>
											</xsl:otherwise>
										</xsl:choose>

								</gmd:version>
								<xsl:for-each select="digtinfo/formspec">
									<gmd:specification>
										<gco:CharacterString>
											<xsl:value-of select="normalize-space(string(.))" />
										</gco:CharacterString>
									</gmd:specification>
								</xsl:for-each>
								<xsl:for-each select="digtinfo/filedec">
									<gmd:fileDecompressionTechnique>
										<gco:CharacterString>
											<xsl:value-of
												select="normalize-space(string(string(.)))"	/>
										</gco:CharacterString>
									</gmd:fileDecompressionTechnique>
								</xsl:for-each>
							</gmd:MD_Format>
						</gmd:distributionFormat>
					</xsl:for-each>
					<xsl:for-each select="$var_metadataRoot/distinfo">
						<xsl:variable name="var1113_distinfo" select="."/>
						<!-- CSDGM requires a distributor for each distinfo element. -->
						<!-- the dist info element can have multiple standard order processes, with 
						multiple online or offline options for each order process. -->
						<gmd:distributor>
							<gmd:MD_Distributor>
								<!-- in csdgm each distributor must have one cntinfo element -->
								<gmd:distributorContact>
									<gmd:CI_ResponsibleParty>
										
										<xsl:apply-templates select="distrib/cntinfo"/>
										<gmd:role>
											<gmd:CI_RoleCode
												codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
												codeListValue="distributor" codeSpace="005">
												<xsl:value-of select="string('distributor')"/>
											</gmd:CI_RoleCode>
										</gmd:role>
									</gmd:CI_ResponsibleParty>
								</gmd:distributorContact>
								<!-- ordering process information -->
								<xsl:for-each select="stdorder/nondig">
									<!--<xsl:variable name="var1159_stdorder" select="parent::*"/>-->
									<gmd:distributionOrderProcess>
										<gmd:MD_StandardOrderProcess>
											<gmd:fees>
												<gco:CharacterString>
													<xsl:value-of select="normalize-space(string(following-sibling::fees))"/>
												</gco:CharacterString>
											</gmd:fees>
											<xsl:if test="$var1113_distinfo/availabl">
												<xsl:if test="timeinfo/sngdate">
													<gmd:plannedAvailableDateTime>
														<xsl:choose>
															<xsl:when test="caldate">
																<xsl:variable name="dateFormat">
																	<xsl:call-template name="usgin:dateFormat">
																		<xsl:with-param name="inputDate" select="normalize-space(string(caldate))"/>
																		<xsl:with-param name="inputTime" select="normalize-space(string(time))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when test="starts-with(string($dateFormat), 'nil')">
																		<xsl:attribute name="indeterminatePosition">
																			<xsl:value-of select="'unknown'"/>
																		</xsl:attribute>
																		<xsl:attribute name="calendarEraName">
																			<xsl:value-of select="concat(string('Cannot interpret datestring: '), caldate, 'T: ', time)"/>
																		</xsl:attribute>
																	</xsl:when>
																	<xsl:otherwise>
																		<gco:DateTime>
																			<xsl:value-of select="$dateFormat"/>
																		</gco:DateTime>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:when>
															<xsl:otherwise>
																<xsl:attribute name="indeterminatePosition">unknown</xsl:attribute>
															</xsl:otherwise>
														</xsl:choose>	
													</gmd:plannedAvailableDateTime>
												</xsl:if>
											</xsl:if>
											<xsl:if test="following-sibling::ordering or $var1113_distinfo/custom">
												<gmd:orderingInstructions>
													<gco:CharacterString>
														<xsl:if test="following-sibling::ordering">
															<xsl:text>Ordering Instructions: </xsl:text>
																<xsl:value-of select="normalize-space(string(following-sibling::ordering))"/><xsl:text>; </xsl:text>
														</xsl:if>
														<!--<xsl:if test = "$var1159_stdorder/digform/digtopt/onlinopt/accinstr">
															<xsl:text>Online access: </xsl:text>
															<xsl:for-each select="$var1159_stdorder/digform/digtopt/onlinopt/accinstr">
																<xsl:value-of select="string(.)"/><xsl:text>;  </xsl:text>
															</xsl:for-each>
														</xsl:if>
														<xsl:if test="$var1159_stdorder/nondig">
															<xsl:text>Non digital version: </xsl:text>
															<xsl:for-each select="$var1159_stdorder/nondig">
																<xsl:value-of select="string(.)"/><xsl:text>; </xsl:text>
															</xsl:for-each>
														</xsl:if>-->
														<xsl:if test="$var1113_distinfo/custom">
															<xsl:text>Custom Order Process: </xsl:text>
															<xsl:for-each select="$var1113_distinfo/custom">
																<xsl:value-of select="string(.)"/><xsl:text>; </xsl:text>
															</xsl:for-each>
														</xsl:if>			
													</gco:CharacterString>
												</gmd:orderingInstructions>
											</xsl:if>
											<xsl:for-each select="following-sibling::turnarnd">
												<gmd:turnaround>
													<gco:CharacterString>
														<xsl:value-of select="normalize-space(string(.))"/>
													</gco:CharacterString>
												</gmd:turnaround>
											</xsl:for-each>
										</gmd:MD_StandardOrderProcess>
									</gmd:distributionOrderProcess>
								</xsl:for-each>
								<!-- for simplicity, follow pattern used by CSDGM, with transfer options (stdorder)
								in binding with distributor-->
								<xsl:for-each select="stdorder/digform">
									<!-- might be online or offline -->
								<gmd:distributorTransferOptions>
									<gmd:MD_DigitalTransferOptions>
										<xsl:if test="number(digtinfo/transize) = digtinfo/transize"> 
											<!-- see https://stackoverflow.com/questions/3854345/xpath-test-if-node-value-is-number for
											explanation of test-->
											<gmd:transferSize>
												<gco:Real>
													<xsl:value-of select="number(.)"/>
												</gco:Real>
											</gmd:transferSize>
										</xsl:if>
										<!-- find text to put in online linkage description and name -->
										<xsl:for-each select="digtopt">
											<xsl:for-each select="onlinopt//networkr[starts-with(normalize-space(.),'http')]">
												<gmd:onLine>
													<gmd:CI_OnlineResource>
														<gmd:linkage>
															<gmd:URL>
																<xsl:value-of select="normalize-space(string(.))"/>
															</gmd:URL>
														</gmd:linkage>
														<gmd:name>
															<gco:CharacterString>
																<xsl:value-of select="string(ancestor::distinfo/resdesc)"/>
															</gco:CharacterString>
														</gmd:name>
														<xsl:if test = "ancestor::computer/following-sibling::accinstr or 
															ancestor::computer/following-sibling::oncomp">
														<gmd:description>
															<gco:CharacterString>
																<xsl:value-of select="concat(string(ancestor::computer/following-sibling::accinstr),'; ',
																	string(ancestor::computer/following-sibling::oncomp))"/>
															</gco:CharacterString>
														</gmd:description>
														</xsl:if>
													</gmd:CI_OnlineResource>
												</gmd:onLine>
											</xsl:for-each>
											
											<xsl:for-each select="offoptn">
												<gmd:offLine>
													<xsl:variable name="var1598_mediumCode">
														<xsl:call-template name="vmf:mediumCode">
															<xsl:with-param name="input"
																select="translate(normalize-space(string(offmedia)),$smallcase,$uppercase)"/>
														</xsl:call-template>
													</xsl:variable>
													<gmd:MD_Medium>
														<gmd:name>
															<gmd:MD_MediumNameCode>
															<xsl:attribute name="codeList">
																<xsl:value-of select="'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumNameCode'"/>
															</xsl:attribute>
															<xsl:attribute name="codeListValue">
																<xsl:value-of select="$var1598_mediumCode"/>
															</xsl:attribute>mediumCodeListValue1">
																<xsl:value-of select="normalize-space(string(offmedia))"/>
															</gmd:MD_MediumNameCode>
														</gmd:name>
														<xsl:for-each select="reccap/recden">
															<xsl:choose>
																<xsl:when test="number(.) = .">
														<gmd:density>
															<gco:Real><xsl:value-of select="number(.)"/></gco:Real>
														</gmd:density>
																</xsl:when>
															<xsl:otherwise>
																<xsl:attribute name="gco:nilReason">missing</xsl:attribute>
															</xsl:otherwise>
															</xsl:choose>
														</xsl:for-each>
														<xsl:if test="reccap/recdenu and string-length(reccap/recdenu)>0">
														<gmd:densityUnits>
															<gco:CharacterString>
															<xsl:value-of select="normalize-space(string(reccap/recdenu))"/>
															</gco:CharacterString>
														</gmd:densityUnits>
														</xsl:if>
														<xsl:for-each select="recfmt">
															<xsl:variable name="var2598_encodingType">
																<xsl:call-template name="vmf:encodingType">
																	<xsl:with-param name="input"
																		select="translate(normalize-space(string(recfmt)),$smallcase,$uppercase)"/>
																</xsl:call-template>
															</xsl:variable>
														<gmd:mediumFormat>
															<gmd:MD_MediumFormatCode>
																<xsl:attribute name="codeList">
																	<xsl:value-of select="'http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_MediumFormatCode'"/>
																</xsl:attribute>
																<xsl:attribute name="codeListValue">
																	<xsl:value-of select="$var2598_encodingType"/>
																</xsl:attribute>mediumCodeListValue1">
																<xsl:value-of select="normalize-space(string(recfmt))"/>
															</gmd:MD_MediumFormatCode>
														</gmd:mediumFormat>
														</xsl:for-each>
														<xsl:if test="compat and string-length(compat)>0">
														<gmd:mediumNote>
															<gco:CharacterString>
																<xsl:value-of select="normalize-space(string(compat))"/>
															</gco:CharacterString>
														</gmd:mediumNote>
														</xsl:if>
													</gmd:MD_Medium>
												</gmd:offLine>
											</xsl:for-each>
										</xsl:for-each>
									</gmd:MD_DigitalTransferOptions>
								</gmd:distributorTransferOptions>
								</xsl:for-each>
							</gmd:MD_Distributor>
						</gmd:distributor>
					</xsl:for-each>
					
					<xsl:if test="$var_metadataRoot/idinfo/citation/citeinfo/onlink">
						<gmd:transferOptions>
							<gmd:MD_DigitalTransferOptions>
							<xsl:for-each select="$var_metadataRoot/idinfo/citation/citeinfo/onlink">
						<gmd:onLine>
							<gmd:CI_OnlineResource>
								<gmd:linkage>
									<gmd:URL>
										<xsl:value-of select="normalize-space(string(.))"/>
									</gmd:URL>
								</gmd:linkage>
								<gmd:name>
									<gco:CharacterString>
										<xsl:value-of select="string(preceding-sibling::title)"/>
									</gco:CharacterString>
								</gmd:name>
								<gmd:description>
									<gco:CharacterString>
										<xsl:value-of select="string('URL from idinfo/citation in CSDGM metadata')"/>
									</gco:CharacterString>
								</gmd:description>
							</gmd:CI_OnlineResource>
						</gmd:onLine>
							</xsl:for-each>
							</gmd:MD_DigitalTransferOptions>
						</gmd:transferOptions>
					</xsl:if>
				</gmd:MD_Distribution>
			</gmd:distributionInfo>
			<!-- data quality section -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:for-each select="dataqual">
					<gmd:dataQualityInfo>
						<gmd:DQ_DataQuality>
							<gmd:scope>
								<gmd:DQ_Scope>
									<gmd:level>
										<gmd:MD_ScopeCode codeListValue="dataset"
											codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ScopeCode"/>
									</gmd:level>
								</gmd:DQ_Scope>
							</gmd:scope>
							<xsl:for-each select="posacc/horizpa">
								<xsl:if test="qhorizpa/horizpav">
									<gmd:report>
										<gmd:DQ_AbsoluteExternalPositionalAccuracy>
											<gmd:nameOfMeasure>
												<gco:CharacterString>
													<xsl:value-of select="'Horizontal Positional Accuracy'"/>
												</gco:CharacterString>
											</gmd:nameOfMeasure>
											<gmd:measureDescription>
												<gco:CharacterString>
													<xsl:for-each select="/metadata/dataqual/posacc/horizpa/qhorizpa[1]/horizpae">
														<xsl:value-of select="normalize-space(string(.))"/>
														<xsl:if test="position() != last()">
															<xsl:text>; </xsl:text>
														</xsl:if>
													</xsl:for-each>
												</gco:CharacterString>
											</gmd:measureDescription>
											<gmd:evaluationMethodDescription>
												<gco:CharacterString>
													<xsl:value-of select="normalize-space(string(horizpar))"/>
												</gco:CharacterString>
											</gmd:evaluationMethodDescription>
											<gmd:result>
												<gmd:DQ_QuantitativeResult>
													<gmd:valueUnit>
														<gml:BaseUnit>
															<xsl:attribute name="gml:id">
																<xsl:value-of select="concat('uom.', generate-id())"/>
															</xsl:attribute>
															<gml:identifier>
																<xsl:attribute name="codeSpace">
																	<xsl:value-of select="concat('uom.', generate-id())"/>
																</xsl:attribute>
															</gml:identifier>
															<gml:unitsSystem>
																<xsl:attribute name="xlink:href">
																	<xsl:value-of select="string('http://www.bipm.org/en/si/')"/>
																</xsl:attribute>
															</gml:unitsSystem>
														</gml:BaseUnit>
													</gmd:valueUnit>
													<gmd:value>
														<gco:Record>
															<xsl:value-of
												select="string(/metadata/dataqual/posacc/horizpa/qhorizpa[1]/horizpav[1])"/>
														</gco:Record>
													</gmd:value>
												</gmd:DQ_QuantitativeResult>
											</gmd:result>
										</gmd:DQ_AbsoluteExternalPositionalAccuracy>
									</gmd:report>
								</xsl:if>
							</xsl:for-each>
							<xsl:for-each select="posacc/vertacc">
								<xsl:if test="qvertpa/vertaccv">
									<gmd:report>
										<gmd:DQ_AbsoluteExternalPositionalAccuracy>
											<gmd:nameOfMeasure>
												<gco:CharacterString>
													<xsl:value-of
												select="'Vertical Positional Accuracy'"/>
												</gco:CharacterString>
											</gmd:nameOfMeasure>
											<gmd:measureDescription>
												<gco:CharacterString>
													<xsl:variable name="DQMeasureDesc">
														<xsl:value-of
												select="count(/metadata/dataqual/posacc/vertacc/qvertpa/vertacce[1])"/>
													</xsl:variable>
													<xsl:for-each
												select="/metadata/dataqual/posacc/vertacc/qvertpa/vertacce[1]">
														<xsl:value-of
												select="normalize-space(string(.))"/>
														<xsl:if test="($DQMeasureDesc > 1)">
															<xsl:value-of select="string(' ')"/>
														</xsl:if>
													</xsl:for-each>
												</gco:CharacterString>
											</gmd:measureDescription>
											<gmd:evaluationMethodDescription>
												<gco:CharacterString>
													<xsl:value-of
												select="normalize-space(string(vertaccr))"/>
												</gco:CharacterString>
											</gmd:evaluationMethodDescription>
											<gmd:result>
												<gmd:DQ_QuantitativeResult>
													<gmd:valueUnit>
														<gml:BaseUnit>
															<xsl:attribute name="gml:id">
																<xsl:value-of select="concat('uom.', generate-id())"/>
															</xsl:attribute>
															<gml:identifier>
																<xsl:attribute name="codeSpace">
																	<xsl:value-of select="string('meters')"/>
																</xsl:attribute>
															</gml:identifier>
															<gml:unitsSystem>
																<xsl:attribute name="xlink:href">
																	<xsl:value-of select="string('http://www.bipm.org/en/si/')"/>
																</xsl:attribute>
															</gml:unitsSystem>
														</gml:BaseUnit>
													</gmd:valueUnit>
													<gmd:value>
														<gco:Record>
															<xsl:value-of select="string(/metadata/dataqual/posacc/vertacc/qvertpa[1]/vertaccv[2])"/>
														</gco:Record>
													</gmd:value>
												</gmd:DQ_QuantitativeResult>
											</gmd:result>
										</gmd:DQ_AbsoluteExternalPositionalAccuracy>
									</gmd:report>
								</xsl:if>
							</xsl:for-each>
							<xsl:if test="complete and string-length(complete)>0">
								<gmd:report>
									<gmd:DQ_CompletenessOmission>
										<gmd:evaluationMethodDescription>
											<gco:CharacterString>
												<xsl:value-of select="normalize-space(string(complete))"/>
											</gco:CharacterString>
										</gmd:evaluationMethodDescription>
										<gmd:result>
												<xsl:attribute name="gco:nilReason">
													<xsl:value-of select="string('inapplicable')"/>
												</xsl:attribute>
										</gmd:result>
									</gmd:DQ_CompletenessOmission>
								</gmd:report>
							</xsl:if>
							<!-- conceptual consistency report -->
							<xsl:if test="logic">
								<gmd:report>
									<gmd:DQ_ConceptualConsistency>
										<gmd:measureDescription>
											<gco:CharacterString>
												<xsl:value-of select="normalize-space(string(logic))"/>
											</gco:CharacterString>
										</gmd:measureDescription>
										<gmd:result>
											<xsl:attribute name="gco:nilReason">
												<xsl:value-of
												select="string('inapplicable')"/>
											</xsl:attribute>
										</gmd:result>
									</gmd:DQ_ConceptualConsistency>
								</gmd:report>
							</xsl:if>
							<!-- attribute accuracy information -->
							<xsl:for-each select="attracc">
								<xsl:variable name="var_attributeAccuracyNode" select="."/>
								<xsl:for-each select="qattracc">
									<xsl:if test="attraccv">
										<gmd:report>
											<gmd:DQ_QuantitativeAttributeAccuracy>
												<gmd:nameOfMeasure>
													<gco:CharacterString>
														<xsl:value-of select="'Quantitative Attribute Accuracy Assessment'"/>
													</gco:CharacterString>
												</gmd:nameOfMeasure>
												<gmd:measureDescription>
													<gco:CharacterString>
														<xsl:value-of select="string(attracce)"/>
													</gco:CharacterString>
												</gmd:measureDescription>
												<gmd:evaluationMethodDescription>
													
														<gco:CharacterString>
															<xsl:for-each select="$var_attributeAccuracyNode/attraccr">
															<xsl:value-of select="string(.)"/>
															</xsl:for-each>
														</gco:CharacterString>
													
												</gmd:evaluationMethodDescription>
												<gmd:result>
													<gmd:DQ_QuantitativeResult>
														<gmd:valueUnit gco:nilReason="inapplicable"/>
														<gmd:value>
															<!--<xsl:for-each select="attraccv"> -->
															<gco:Record>
																<xsl:for-each select="/metadata/dataqual/attracc/qattracc/attraccv">
																	<xsl:value-of select="normalize-space(string(.))"/>
																	<xsl:if test="position() != last()">
																		<xsl:text>; </xsl:text>
																	</xsl:if>
																</xsl:for-each>
															</gco:Record>
														</gmd:value>
													</gmd:DQ_QuantitativeResult>
												</gmd:result>
											</gmd:DQ_QuantitativeAttributeAccuracy>
										</gmd:report>
									</xsl:if>
								</xsl:for-each>
							</xsl:for-each>
							<!-- now handle the lineage/provenance information -->
							<xsl:if test="lineage/procstep or lineage/srcinfo">
								<gmd:lineage>
									<gmd:LI_Lineage>
										<gmd:statement>
											<gco:CharacterString>missing</gco:CharacterString>
										</gmd:statement>
										<xsl:for-each select="lineage/procstep">
											<xsl:variable name="var_lineageProcessingStepNode" select="."/>
											<gmd:processStep>
												<gmd:LI_ProcessStep>
													<gmd:description>
														<gco:CharacterString>
															<xsl:value-of select="string(procdesc)"/>
														</gco:CharacterString>
													</gmd:description>
													<gmd:dateTime>
														<xsl:choose>
															<xsl:when test="procdate">
																<xsl:variable name="dateFormat">
																	<xsl:call-template name="usgin:dateFormat">
																		<xsl:with-param name="inputDate" select="normalize-space(string(procdate))"/>
																		<xsl:with-param name="inputTime" select="normalize-space(string(proctime))"/>
																	</xsl:call-template>
																</xsl:variable>
																<xsl:choose>
																	<xsl:when test="starts-with(string($dateFormat), 'nil')">
																		<xsl:attribute name="gco:nilReason">
																			<xsl:value-of select="'missing'"/>
																		</xsl:attribute>
																	</xsl:when>
																	<xsl:otherwise>
																		<gco:DateTime>
																			<xsl:value-of select="$dateFormat"/>
																		</gco:DateTime>
																	</xsl:otherwise>
																</xsl:choose>
															</xsl:when>
															<xsl:otherwise>
																<xsl:attribute name="indeterminatePosition">unknown</xsl:attribute>
															</xsl:otherwise>
														</xsl:choose>
													</gmd:dateTime>
													<xsl:for-each select="proccont">
														<gmd:processor>
															<gmd:CI_ResponsibleParty>
																<xsl:apply-templates select ="cntinfo"/>															<gmd:role>
																	<gmd:CI_RoleCode
												codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
												codeListValue="processor" codeSpace="009">
																		<xsl:value-of select="string('processor')"/>
																	</gmd:CI_RoleCode>
																	<!-- /xsl:if -->
																</gmd:role>
															</gmd:CI_ResponsibleParty>
														</gmd:processor>
													</xsl:for-each>
													
													<xsl:for-each select="srcused">
														<!-- csdgm puts a srcinfo collection of source citations in the root of the lineage section,
														each with an abbreviation used as a foreign key to reference the source in the srcused for the
														processing steps. The srccitea -->
														<gmd:source>
															<gmd:LI_Source>
																<gmd:sourceCitation>
																	<xsl:apply-templates select = "//srccitea[.=srcused]/preceding-sibling::srccite/citeinfo"/>
																</gmd:sourceCitation>
															</gmd:LI_Source>
														</gmd:source>
													</xsl:for-each>
												</gmd:LI_ProcessStep>
											</gmd:processStep>
										</xsl:for-each>
										<xsl:for-each select="lineage/srcinfo">
											<gmd:source>
												<gmd:LI_Source>
													<xsl:if test="strcontr or typesrc">
														<gmd:description>
															<gco:CharacterString>
																<xsl:value-of select="concat('Source Contribution: ', string(srccontr), ' ', string(typesrc))"/>
															</gco:CharacterString>
														</gmd:description>
													</xsl:if>
													<xsl:if	test="srcscale">
														<gmd:scaleDenominator>
															<gmd:MD_RepresentativeFraction>
																<gmd:denominator>
																	<xsl:choose>
																		<xsl:when test="string(srcscale) = 'unknown'">
																			<xsl:attribute name="gco:nilReason">
																				<xsl:value-of select="string('unknown')"/>
																			</xsl:attribute>
																		</xsl:when>
																		<xsl:when test="number(srcscale) = srcscale">
																			<gco:Integer>
																				<xsl:value-of select="string(srcscale)"/>
																			</gco:Integer>
																		</xsl:when>
																		<xsl:otherwise>
																			<xsl:attribute name="gco:nilReason">
																				<xsl:value-of select="string('missing')"/>
																			</xsl:attribute>
																		</xsl:otherwise>
																	</xsl:choose>
																</gmd:denominator>
															</gmd:MD_RepresentativeFraction>
														</gmd:scaleDenominator>
													</xsl:if>
													<gmd:sourceCitation>
														<gmd:CI_Citation>
															<xsl:apply-templates select="srccite/citeinfo"/>
														</gmd:CI_Citation>
													</gmd:sourceCitation>
													<xsl:if test="srctime/timeinfo">
														<gmd:sourceExtent>
															<gmd:EX_Extent>
																<xsl:for-each select="srctime/timeinfo/sngdate">
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:if	test="(contains(string(caldate), 'unknown') or contains(string(caldate), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason">
																						<xsl:value-of select="normalize-space(string(caldate))"/>
																					</xsl:attribute>
																				</xsl:if>
																				<gml:TimeInstant>
																					<xsl:attribute name="gml:id">
																						<xsl:value-of	select="concat('TempEx.', generate-id())"/>
																					</xsl:attribute>
																					<gml:description>
																						<xsl:value-of	select="string(srctime/srccurr)"	/>
																					</gml:description>
																					
																					<gml:timePosition>
																						<xsl:choose>
																							<xsl:when test="srctime//caldate">
																								<xsl:variable name="dateFormat">
																									<xsl:call-template name="usgin:dateFormat">
																										<xsl:with-param name="inputDate" select="normalize-space(string(srctime//caldate))"/>
																										<xsl:with-param name="inputTime" select="normalize-space(string(srctime//time))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:choose>
																									<xsl:when test="starts-with(string($dateFormat), 'nil')">
																										<xsl:attribute name="indeterminatePosition">
																											<xsl:value-of select="'unknown'"/>
																										</xsl:attribute>
																										<xsl:attribute name="calendarEraName">
																											<xsl:value-of select="concat(string('Cannot interpret datestring: '), srctime//caldate, 'T: ', srctime//time)"/>
																										</xsl:attribute>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:value-of select="$dateFormat"/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:attribute name="indeterminatePosition">unknown</xsl:attribute>
																							</xsl:otherwise>
																						</xsl:choose>
	
																					</gml:timePosition>
																				</gml:TimeInstant>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
																<xsl:for-each select="srctime/timeinfo/mdattim/sngdate">
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:if test="(contains(string(caldate), 'unknown') or contains(string(caldate), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason">
																						<xsl:value-of select="normalize-space(string(caldate))"	/>
																					</xsl:attribute>
																				</xsl:if>
																				<gml:TimeInstant>
																					<xsl:attribute name="gml:id">
																						<xsl:value-of	select="concat('sourceTimeInst.', generate-id())"/>
																					</xsl:attribute>
																					<gml:description>
																						<xsl:value-of select="string(srctime/srccurr)"/>
																					</gml:description>
																					
																					<gml:timePosition>
																						<xsl:choose>
																							<xsl:when test="caldate">
																								<xsl:variable name="dateFormat">
																									<xsl:call-template name="usgin:dateFormat">
																										<xsl:with-param name="inputDate" select="normalize-space(string(caldate))"/>
																										<xsl:with-param name="inputTime" select="normalize-space(string(time))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:choose>
																									<xsl:when test="starts-with(string($dateFormat), 'nil')">
																										<xsl:attribute name="indeterminatePosition">
																											<xsl:value-of select="'unknown'"/>
																										</xsl:attribute>
																										<xsl:attribute name="calendarEraName">
																											<xsl:value-of select="concat(string('Cannot interpret datestring: '), caldate, 'T: ', time)"/>
																										</xsl:attribute>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:value-of select="$dateFormat"/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:attribute name="indeterminatePosition">unknown</xsl:attribute>
																							</xsl:otherwise>
																						</xsl:choose>
																					</gml:timePosition>
																				</gml:TimeInstant>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
																<xsl:for-each select="srctime/timeinfo/rngdates">
																	<xsl:variable name="var_rngdatesNode" select="."/>
																	<gmd:temporalElement>
																		<gmd:EX_TemporalExtent>
																			<gmd:extent>
																				<xsl:if test="(contains(string(begdate), 'unknown') or contains(string(begdate), 'unpublished'))">
																					<xsl:attribute name="gco:nilReason">
																						<xsl:value-of select="normalize-space(string(begdate))"	/>
																					</xsl:attribute>
																				</xsl:if>
																				<gml:TimePeriod>
																					<xsl:attribute name="gml:id">
																						<xsl:value-of	select="concat('srcTempEx.', generate-id())"/>
																					</xsl:attribute>
																					<gml:description>
																						<xsl:value-of select="string(srctime/srccurr)"/>
																					</gml:description>
																					<gml:beginPosition>
																						<xsl:choose>
																							<xsl:when test="begdate">
																								<xsl:variable name="dateFormat">
																									<xsl:call-template name="usgin:dateFormat">
																										<xsl:with-param name="inputDate" select="normalize-space(string(begdate))"/>
																										<xsl:with-param name="inputTime" select="normalize-space(string(begtime))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:choose>
																									<xsl:when	test="contains(string($var_rngdatesNode/begdate), 'present')">
																										<xsl:attribute name="indeterminatePosition">
																											<xsl:value-of select="string('now')"/>
																										</xsl:attribute>
																									</xsl:when>
																									<xsl:when test="starts-with(string($dateFormat), 'nil')">
																										<xsl:attribute name="indeterminatePosition">
																											<xsl:value-of select="'unknown'"/>
																										</xsl:attribute>
																										<xsl:attribute name="calendarEraName">
																											<xsl:value-of select="concat(string('Cannot interpret datestring: '), begdate, 'T: ', endtime)"/>
																										</xsl:attribute>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:value-of select="$dateFormat"/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:attribute name="indeterminatePosition">unknown</xsl:attribute>
																							</xsl:otherwise>
																						</xsl:choose>
																						</gml:beginPosition>
																					<gml:endPosition>
																						<xsl:choose>
																							<xsl:when test="enddate">
																								<xsl:variable name="dateFormat">
																									<xsl:call-template name="usgin:dateFormat">
																										<xsl:with-param name="inputDate" select="normalize-space(string(enddate))"/>
																										<xsl:with-param name="inputTime" select="normalize-space(string(endtime))"/>
																									</xsl:call-template>
																								</xsl:variable>
																								<xsl:choose>
																									<xsl:when	test="contains(string($var_rngdatesNode/enddate), 'present')">
																										<xsl:attribute name="indeterminatePosition">
																											<xsl:value-of select="string('now')"/>
																										</xsl:attribute>
																									</xsl:when>
																									<xsl:when test="starts-with(string($dateFormat), 'nil')">
																										<xsl:attribute name="indeterminatePosition">
																											<xsl:value-of select="'unknown'"/>
																										</xsl:attribute>
																										<xsl:attribute name="calendarEraName">
																											<xsl:value-of select="concat(string('Cannot interpret datestring: '), enddate, 'T: ', endtime)"/>
																										</xsl:attribute>
																									</xsl:when>
																									<xsl:otherwise>
																										<xsl:value-of select="$dateFormat"/>
																									</xsl:otherwise>
																								</xsl:choose>
																							</xsl:when>
																							<xsl:otherwise>
																								<xsl:attribute name="indeterminatePosition">unknown</xsl:attribute>
																							</xsl:otherwise>
																						</xsl:choose>
																					</gml:endPosition>
																				</gml:TimePeriod>
																			</gmd:extent>
																		</gmd:EX_TemporalExtent>
																	</gmd:temporalElement>
																</xsl:for-each>
															</gmd:EX_Extent>
														</gmd:sourceExtent>
													</xsl:if>
												</gmd:LI_Source>
											</gmd:source>
										</xsl:for-each>
									</gmd:LI_Lineage>
								</gmd:lineage>
							</xsl:if>
						</gmd:DQ_DataQuality>
					</gmd:dataQualityInfo>
				</xsl:for-each>
			</xsl:for-each>
			<!-- metadata constraints -->
			<xsl:for-each select="$var_metadataRoot">
				<xsl:variable name="var2374_metadata" select="."/>
				<xsl:for-each select="metainfo/metac">
					<gmd:metadataConstraints>
						<gmd:MD_LegalConstraints>
							<gmd:accessConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:attribute name="codeList">
										<xsl:value-of
											select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode')"/>
									</xsl:attribute>
									<xsl:attribute name="codeListValue">
										<xsl:value-of select="string('otherRestrictions')"/>
									</xsl:attribute>
									<xsl:attribute name="codeSpace">
										<xsl:value-of select="string('008')"/>
									</xsl:attribute>
								</gmd:MD_RestrictionCode>
							</gmd:accessConstraints>
							<gmd:useConstraints>
								<gmd:MD_RestrictionCode>
									<xsl:if test="$var2374_metadata/metainfo/metuc">
										<xsl:attribute name="codeList">
											<xsl:value-of
												select="string('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_RestrictionCode')"/>
										</xsl:attribute>
									</xsl:if>
									<xsl:if test="$var2374_metadata/metainfo/metuc">
										<xsl:attribute name="codeListValue">
											<xsl:value-of
												select="string('otherRestrictions')"/>
										</xsl:attribute>
									</xsl:if>
									<xsl:if test="$var2374_metadata/metainfo/metuc">
										<xsl:attribute name="codeSpace">
											<xsl:value-of select="string('008')"/>
										</xsl:attribute>
									</xsl:if>
								</gmd:MD_RestrictionCode>
							</gmd:useConstraints>
							<gmd:otherConstraints>
								<xsl:variable name="var2378_cond_result_exists">
									<xsl:choose>
										<xsl:when test="$var2374_metadata/metainfo/metuc">
											<xsl:for-each select="$var2374_metadata/metainfo/metuc">
												<xsl:value-of select="string(.)"/>
											</xsl:for-each>
										</xsl:when>
										<xsl:otherwise>
											<xsl:value-of select="' '"/>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:variable>
								<xsl:if test="$var2378_cond_result_exists">
									<gco:CharacterString>
										<xsl:variable name="var2379_cond_result_exists">
											<xsl:choose>
												<xsl:when test="$var2374_metadata/metainfo/metuc">
													<xsl:value-of select="' Metadata Use Constraints: '"/>
												</xsl:when>
												<xsl:otherwise>
													<xsl:value-of select="' '"/>
												</xsl:otherwise>
											</xsl:choose>
										</xsl:variable>
										<xsl:value-of
											select="normalize-space(concat('Metadata Access Constraints: ', string(.), $var2379_cond_result_exists, $var2378_cond_result_exists))"/>
									</gco:CharacterString>
								</xsl:if>
							</gmd:otherConstraints>
						</gmd:MD_LegalConstraints>
					</gmd:metadataConstraints>
				</xsl:for-each>
			</xsl:for-each>
			<!-- security constraints -->
			<xsl:for-each select="$var_metadataRoot/metainfo/metsi">
				<xsl:variable name="var_lookupSecurityClassType">
					<xsl:call-template name="vmf:securityClassType">
						<xsl:with-param name="input"
							select="translate(normalize-space(string(metsc)),$smallcase,$uppercase)"/>
					</xsl:call-template>
				</xsl:variable>
				<gmd:metadataConstraints>
					<gmd:MD_SecurityConstraints>
						<xsl:choose>
							<xsl:when
								test="$var_lookupSecurityClassType and string-length(string($var_lookupSecurityClassType)) > 0">
								<gmd:classification>
									<gmd:MD_ClassificationCode>
										<xsl:attribute name="codeListValue">
											<xsl:value-of
												select="string($var_lookupSecurityClassType)"/>
										</xsl:attribute>
										<xsl:attribute name="codeList">
											<xsl:value-of
												select="string(xs:anyURI('http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#MD_ClassificationCode'))"
											/>
										</xsl:attribute>
										<xsl:variable name="var2388_result_securityClassCode">
											<xsl:call-template name="vmf:securityClassCode">
												<xsl:with-param name="input"
												select="translate(normalize-space(string(metsc)),$smallcase,$uppercase)"
												/>
											</xsl:call-template>
										</xsl:variable>
										<xsl:if test="$var2388_result_securityClassCode">
											<xsl:attribute name="codeSpace">
												<xsl:value-of
													select="string($var2388_result_securityClassCode)"/>
											</xsl:attribute>
										</xsl:if>
									</gmd:MD_ClassificationCode>
								</gmd:classification>
							</xsl:when>
							<xsl:otherwise>
								<gmd:classification gco:nilReason="missing"/>
							</xsl:otherwise>
						</xsl:choose>
						<xsl:if test="metscs and string-length(string(metscs)) > 0">
							<gmd:classificationSystem>
								<gco:CharacterString>
									<xsl:value-of select="string(metscs)"/>
								</gco:CharacterString>
							</gmd:classificationSystem>
						</xsl:if>
					</gmd:MD_SecurityConstraints>
				</gmd:metadataConstraints>
			</xsl:for-each>
			<!-- metadata maintenance -->
			<gmd:metadataMaintenance>
				<gmd:MD_MaintenanceInformation>
					<gmd:maintenanceAndUpdateFrequency>
						<xsl:attribute name="gco:nilReason">
							<xsl:value-of select="string(string('unknown'))"/>
						</xsl:attribute>
					</gmd:maintenanceAndUpdateFrequency>
					<!--metfrd Metadata Future Review Date - the date by which the metadata entry should be reviewed. -->
					<xsl:for-each select="$var_metadataRoot/metainfo/metfrd">
						<gmd:dateOfNextUpdate>
							<xsl:choose>
								<xsl:when test=".">
									<xsl:variable name="dateFormat">
										<xsl:call-template name="usgin:dateFormat">
											<xsl:with-param name="inputDate" select="normalize-space(string(.))"/>
											<xsl:with-param name="inputTime"/>
										</xsl:call-template>
									</xsl:variable>
									<xsl:choose>
										<xsl:when test="starts-with(string($dateFormat), 'nil')">
											<xsl:attribute name="indeterminatePosition">
												<xsl:value-of select="'unknown'"/>
											</xsl:attribute>
											<xsl:attribute name="calendarEraName">
												<xsl:value-of select="concat(string('Cannot interpret datestring: '), string(.))"/>
											</xsl:attribute>
										</xsl:when>
										<xsl:otherwise>
											<gco:DateTime>
												<xsl:value-of select="$dateFormat"/>
											</gco:DateTime>
										</xsl:otherwise>
									</xsl:choose>
								</xsl:when>
								<xsl:otherwise>
									<xsl:attribute name="indeterminatePosition">unknown</xsl:attribute>
								</xsl:otherwise>
							</xsl:choose>	
						</gmd:dateOfNextUpdate>
					</xsl:for-each>
					<gmd:maintenanceNote>
						<xsl:for-each select="$var_metadataRoot">
							<xsl:variable name="var2413_map_select_metadata">
								<xsl:variable name="var_DateTemp">
									<xsl:call-template name="usgin:TimePositionFormat">
										<xsl:with-param name="inputDate" select="(metainfo/metrd)"/>
										<xsl:with-param name="inputTime"/>
									</xsl:call-template>
								</xsl:variable>
								<xsl:choose>
									<xsl:when test="$var_DateTemp">
										<xsl:value-of select="concat(' Most recent metadata content review date: ', string($var_DateTemp))"/>
									</xsl:when>
									<xsl:otherwise>
										<xsl:value-of select="string('')"/>
									</xsl:otherwise>
								</xsl:choose>
								<!-- metadata review date; if present will be concatenated with the maintenance note -->:
								<!--xsl:for-each select="$var_metadataRoot/metainfo/metrd">
									<xsl:variable name="var2417_cond_result_logicalor">
										<xsl:if test="not(((contains(lower-case(normalize-space(string(.))), 'unknown') or contains(lower-case(normalize-space(string(.))), 'unpublished')) or contains(lower-case(normalize-space(string(.))), 'present')))">
											<xsl:variable name="var2422_map_result_distinctvalues">
												<xsl:for-each select="distinct-values(if (((contains(lower-case(normalize-space(string(.))), 'unknown') or contains(lower-case(normalize-space(string(.))), 'unpublished')) or contains(lower-case(normalize-space(string(.))), 'present'))) then () else concat(substring(lower-case(normalize-space(string(.))), 0, 5), '-', substring(lower-case(normalize-space(string(.))), 5, 2), '-', substring(lower-case(normalize-space(string(.))), 7,2)))">
													<xsl:choose>
														<xsl:when test="ends-with(., '-')">
															<xsl:if test="ends-with(., '-')">
																<xsl:if test="exists((if (((('0' != .) and ('false' != .)) and boolean(.))) then substring(., xs:double(xs:decimal(0)), xs:double(string-length(.))) else ()))">
																	<xsl:value-of select="(if (((('0' != .) and ('false' != .)) and boolean(.))) then substring(., xs:double(xs:decimal(0)), xs:double(string-length(.))) else ())"/>
																</xsl:if>
															</xsl:if>
														</xsl:when>
														<xsl:otherwise>
															<xsl:value-of select="."/>
														</xsl:otherwise>
													</xsl:choose>
												</xsl:for-each>
											</xsl:variable>
											<xsl:variable name="var2421_map_result_distinctvalues">
												<xsl:for-each select="distinct-values($var2422_map_result_distinctvalues)">
													<xsl:variable name="var2427_cond_result_endswith">
														<xsl:choose>
															<xsl:when test="ends-with(normalize-space(.), '-')">
																<xsl:if test="ends-with(normalize-space(.), '-')">
																	<xsl:if test="exists((if (((('0' != normalize-space(.)) and ('false' != normalize-space(.))) and boolean(normalize-space(.)))) then substring(normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(string-length(normalize-space(.))) - xs:decimal(0)))) else ()))">
																		<xsl:value-of select="(if (((('0' != normalize-space(.)) and ('false' != normalize-space(.))) and boolean(normalize-space(.)))) then substring(normalize-space(.), xs:double(xs:decimal(0)), xs:double((xs:decimal(string-length(normalize-space(.))) - xs:decimal(0)))) else ())"/>
																	</xsl:if>
																</xsl:if>
															</xsl:when>
															<xsl:otherwise>
																<xsl:value-of select="."/>
															</xsl:otherwise>
														</xsl:choose>
													</xsl:variable>
													<xsl:if test="exists($var2427_cond_result_endswith)">
														<xsl:value-of select="$var2427_cond_result_endswith"/>
													</xsl:if>
												</xsl:for-each>
											</xsl:variable>
											<xsl:if test="exists($var2421_map_result_distinctvalues)">
												<xsl:value-of select="string-join($var2421_map_result_distinctvalues, ' ')"/>
											</xsl:if>
										</xsl:if>
									</xsl:variable>
									<xsl:for-each select="$var2417_cond_result_logicalor">
										<xsl:value-of select="string(normalize-space(.))"/>
									</xsl:for-each>
								</xsl:for-each -->
							</xsl:variable>
								<gco:CharacterString>
									<xsl:value-of
										select="normalize-space(concat('This metadata was automatically generated from the ', string(metainfo/metstdn), ' standard, version ', string(metainfo/metstdv), ' using the August 2011-REH version of the FGDC CSDGM to ISO 19115-2 transform modified and updatated by SMR 2018-05-26 to work with xslt v1.0; generates USGIN compatible ISO19139 XML. ', $var2413_map_select_metadata))"/>
								</gco:CharacterString>
						</xsl:for-each>
					</gmd:maintenanceNote>
					<gmd:contact>
						<gmd:CI_ResponsibleParty>
							<gmd:positionName>
								<gco:CharacterString>metadata editor</gco:CharacterString>
							</gmd:positionName>
							<gmd:contactInfo>
								<gmd:CI_Contact>
									<gmd:address>
										<gmd:CI_Address>
											<gmd:electronicMailAddress>
												<gco:CharacterString>metadata@missing.org</gco:CharacterString>
											</gmd:electronicMailAddress>
										</gmd:CI_Address>
									</gmd:address>
								</gmd:CI_Contact>
							</gmd:contactInfo>
							<gmd:role>
								<gmd:CI_RoleCode
									codeList="http://www.isotc211.org/2005/resources/Codelist/gmxCodelists.xml#CI_RoleCode"
									codeListValue="processor" codeSpace="007"
									>processor</gmd:CI_RoleCode>
							</gmd:role>
						</gmd:CI_ResponsibleParty>
					</gmd:contact>
				</gmd:MD_MaintenanceInformation>
			</gmd:metadataMaintenance>
		</gmd:MD_Metadata>
	</xsl:template>
	<!-- Map projection display handlers, this stuff gets put in the abstract -->
	<!-- Map Projections -->
	<xsl:template match="albers | equicon | lambertc">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="gnomonic | lamberta | orthogr | stereo | gvnsp">
		<xsl:for-each select="../gvnsp">
			<xsl:apply-templates select="heightpt"/>
		</xsl:for-each>
		<xsl:apply-templates select="longpc"/>
		<xsl:apply-templates select="latprjc"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="azimequi | polycon | transmer">
		<xsl:for-each select="../transmer">
			<xsl:apply-templates select="sfctrmer"/>
		</xsl:for-each>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="miller | sinusoid | vdgrin">
		<xsl:for-each select="../equirect">
			<xsl:apply-templates select="stdparll"/>
		</xsl:for-each>
		<xsl:for-each select="../mercator">
			<xsl:apply-templates select="stdparll"/>
			<xsl:apply-templates select="sfequat"/>
		</xsl:for-each>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="equirect">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="mercator">
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="sfequat"/>
		<xsl:apply-templates select="longcm"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="polarst">
		<xsl:apply-templates select="svlong"/>
		<xsl:apply-templates select="stdparll"/>
		<xsl:apply-templates select="sfprjorg"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="obqmerc">
		<xsl:apply-templates select="sfctrlin"/>
		<xsl:apply-templates select="obqlazim"/>
		<xsl:apply-templates select="obqlpt"/>
		<xsl:apply-templates select="latprjo"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="spaceobq">
		<xsl:apply-templates select="landsat"/>
		<xsl:apply-templates select="pathnum"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="robinson">
		<xsl:apply-templates select="longpc"/>
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<xsl:template match="modsak">
		<xsl:apply-templates select="feast"/>
		<xsl:apply-templates select="fnorth"/>
	</xsl:template>
	<!-- Map Projection Parameters -->
	<xsl:template match="stdparll"> Standard_Parallel: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="longcm"> Longitude_of_Central_Meridian: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="latprjo"> Latitude_of_Projection_Origin: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="feast"> False_Easting: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="fnorth"> False_Northing: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfequat"> Scale_Factor_at_Equator: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="heightpt"> Height_of_Perspective_Point_Above_Surface: <xsl:value-of
			select="."/>
	</xsl:template>
	<xsl:template match="longpc"> Longitude_of_Projection_Center: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="latprjc"> Latitude_of_Projection_Center: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfctrlin"> Scale_Factor_at_Center_Line: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="obqlazim"> Oblique_Line_Azimuth: <xsl:value-of select="."/>
		<xsl:for-each select="azimangl"> Azimuthal_Angle: <xsl:value-of select="."/>
		</xsl:for-each>
		<xsl:for-each select="azimptl"> Azimuthal_Measure_Point_Longitude: <xsl:value-of select="."
			/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="obqlpt"> Oblique_Line_Point: <xsl:value-of select="."/>
		<xsl:for-each select="obqllat"> Oblique_Line_Latitude: <xsl:value-of select="."/>
		</xsl:for-each>
		<xsl:for-each select="obqllong"> Oblique_Line_Longitude: <xsl:value-of select="."/>
		</xsl:for-each>
	</xsl:template>
	<xsl:template match="svlong"> Straight_Vertical_Longitude_from_Pole: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfprjorg"> Scale_Factor_at_Projection_Origin: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="landsat"> Landsat_Number: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="pathnum"> Path_Number: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="sfctrmer"> Scale_Factor_at_Central_Meridian: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="otherprj"> Other_Projection's_Definition: <xsl:value-of select="."/>
	</xsl:template>
	<xsl:template match="attr">
		<!-- template to handle attributes of attributes, don't allow recursion --> Attribute Label:
		<xsl:value-of select="attrlabl"/> Definition: <xsl:value-of select="attrdef"/> Source:
		<xsl:value-of select="attrdefs"/> Attribute of Attribute Domain: <xsl:for-each
			select="attrdomv"> Attribute_Domain_Values: <xsl:for-each select="edom">
				Enumerated_Domain: <xsl:for-each select="edomv"> Value: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="edomvd"> Value_Definition: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="edomvds"> Value_Definition_Source: <xsl:value-of select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<!-- end enumerated domain -->
			<xsl:for-each select="rdom"> Range_Domain: <xsl:for-each select="rdommin">
					Range_Minimum: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="rdommax"> Range_Maximum: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="attrunit"> Units_of_Measure: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="attrmres"> Attribute_Measurement_Resolution: <xsl:value-of
						select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="codesetd"> Codeset Domain: <xsl:for-each select="codesetn">
					Codeset Name: <xsl:value-of select="."/>
				</xsl:for-each>
				<xsl:for-each select="codesets"> Codeset Source: <xsl:value-of select="."/>
				</xsl:for-each>
			</xsl:for-each>
			<xsl:for-each select="udom"> Unrepresentable Domain: <xsl:value-of select="."/>
			</xsl:for-each>
		</xsl:for-each>
	</xsl:template>
</xsl:stylesheet>
